<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£ 3D - Psychology Megacity</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #001122, #003366, #004488);
            font-family: 'Roboto', 'Arial', sans-serif;
            overflow: hidden;
            cursor: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: #00ffff;
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 350px;
            z-index: 100;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: #00ff00;
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .district-button {
            background: linear-gradient(135deg, #1e3c72, #2a5298, #667eea);
            color: #ffffff;
            border: 2px solid #00ffff;
            padding: 12px 18px;
            margin: 4px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 255, 255, 0.3);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .district-button:hover {
            transform: scale(1.1) translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 255, 255, 0.6);
            background: linear-gradient(135deg, #667eea, #764ba2, #a8e6cf);
            border-color: #ffffff;
        }
        
        #download-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24, #ff3838);
            color: white;
            border: 2px solid #ffffff;
            padding: 15px 25px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            transition: all 0.3s ease;
            box-shadow: 0 6px 12px rgba(255, 107, 107, 0.4);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        #download-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 16px rgba(255, 107, 107, 0.6);
        }
        
        #legend {
            position: absolute;
            top: 80px;
            right: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: #ffff00;
            padding: 20px;
            border-radius: 15px;
            font-size: 12px;
            max-width: 220px;
            z-index: 100;
            border: 2px solid #ffff00;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        #camera-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: #ff69b4;
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            border: 2px solid #ff69b4;
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .camera-button {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            border: 1px solid #ffffff;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .camera-button:hover {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            transform: scale(1.05);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <button id="download-btn" onclick="downloadHTML()">ğŸ“¥ HTMLãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        
        <div id="info">
            <h3>ğŸŒ† å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£</h3>
            <div id="district-info">
                <strong>çµ±è¨ˆåŒº (ä¸­å›½é¢¨)</strong><br>
                è¨˜è¿°çµ±è¨ˆã€æ¨æ¸¬çµ±è¨ˆã€å¤šå¤‰é‡è§£æã®ä¸­å¿ƒåœ°<br>
                <em>ãƒã‚¦ã‚¹ã§å›è»¢ã€ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ </em>
            </div>
        </div>
        
        <div id="camera-controls">
            <h4>ğŸ¥ ã‚«ãƒ¡ãƒ©åˆ¶å¾¡</h4>
            <button class="camera-button" onclick="setViewMode('orbit')">ğŸŒ è»Œé“ã‚«ãƒ¡ãƒ©</button>
            <button class="camera-button" onclick="setViewMode('fly')">ğŸš ãƒ•ãƒ©ã‚¤ã‚«ãƒ¡ãƒ©</button>
            <button class="camera-button" onclick="setViewMode('fps')">ğŸ‘¤ FPSã‚«ãƒ¡ãƒ©</button><br>
            <button class="camera-button" onclick="resetCamera()">ğŸ¯ ãƒªã‚»ãƒƒãƒˆ</button>
            <button class="camera-button" onclick="toggleWireframe()">ğŸ“ ãƒ¯ã‚¤ãƒ¤ãƒ¼</button>
            <button class="camera-button" onclick="toggleFullscreen()">ğŸ–¥ï¸ å…¨ç”»é¢</button>
        </div>
        
        <div id="legend">
            <h4>ğŸ˜ï¸ åŒºåŸŸå‡¡ä¾‹</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff69b4;"></div>
                <span>ğŸ“Š çµ±è¨ˆåŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #87ceeb;"></div>
                <span>ğŸ§  èªçŸ¥åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #98fb98;"></div>
                <span>ğŸ‘¶ ç™ºé”åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffd700;"></div>
                <span>ğŸ¥ è‡¨åºŠåŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffa500;"></div>
                <span>ğŸ“š å­¦ç¿’åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #da70d6;"></div>
                <span>ğŸ‘¥ ç¤¾ä¼šåŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #40e0d0;"></div>
                <span>ğŸ’­ äººæ ¼åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ee82ee;"></div>
                <span>ğŸ‘ï¸ çŸ¥è¦šåŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #20b2aa;"></div>
                <span>âš¡ ç¥çµŒåŒº</span>
            </div>
        </div>
        
        <div id="controls">
            <h4>ğŸ® åŒºåŸŸé¸æŠ</h4>
            <button class="district-button" onclick="focusDistrict('statistics')">ğŸ“Š çµ±è¨ˆåŒº</button>
            <button class="district-button" onclick="focusDistrict('cognitive')">ğŸ§  èªçŸ¥åŒº</button>
            <button class="district-button" onclick="focusDistrict('development')">ğŸ‘¶ ç™ºé”åŒº</button>
            <button class="district-button" onclick="focusDistrict('clinical')">ğŸ¥ è‡¨åºŠåŒº</button><br>
            <button class="district-button" onclick="focusDistrict('learning')">ğŸ“š å­¦ç¿’åŒº</button>
            <button class="district-button" onclick="focusDistrict('social')">ğŸ‘¥ ç¤¾ä¼šåŒº</button>
            <button class="district-button" onclick="focusDistrict('personality')">ğŸ’­ äººæ ¼åŒº</button>
            <button class="district-button" onclick="focusDistrict('perception')">ğŸ‘ï¸ çŸ¥è¦šåŒº</button><br>
            <button class="district-button" onclick="focusDistrict('neural')">âš¡ ç¥çµŒåŒº</button>
            <button class="district-button" onclick="focusDistrict('overview')">ğŸŒ† å…¨ä½“è¡¨ç¤º</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®åˆæœŸåŒ–
        let scene, camera, renderer;
        let districts = {};
        let currentDistrict = null;
        
        // 3DCGæ‹¡å¼µå¤‰æ•°
        let viewMode = 'orbit';
        let keys = {};
        let wireframeMode = false;
        let isFullscreen = false;
        let velocity = new THREE.Vector3();
        let moveSpeed = 0.5;
        let flySpeed = 1.0;
        
        // åŒºåŸŸæƒ…å ±
        const districtData = {
            statistics: {
                name: "ğŸ“Š çµ±è¨ˆåŒº (ä¸­å›½é¢¨)",
                description: "è¨˜è¿°çµ±è¨ˆã€æ¨æ¸¬çµ±è¨ˆã€å¤šå¤‰é‡è§£æã®ç ”ç©¶ä¸­å¿ƒåœ°ã€‚ä¸Šæµ·ã®é‡‘èè¡—ã®ã‚ˆã†ãªé«˜å±¤ãƒ“ãƒ«ç¾¤ã§æ•°å€¤ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ã€‚",
                color: 0xff69b4,
                position: [-40, 0, -40]
            },
            cognitive: {
                name: "ğŸ§  èªçŸ¥åŒº (æ—¥æœ¬é¢¨)",
                description: "è¨˜æ†¶ã€æ³¨æ„ã€å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã®ç ”ç©¶ã‚¨ãƒªã‚¢ã€‚æ±äº¬ã®é›»å­å›è·¯ã®ã‚ˆã†ãªé“è·¯ç¶²ã§èªçŸ¥ãƒ—ãƒ­ã‚»ã‚¹ã‚’è¡¨ç¾ã€‚",
                color: 0x87ceeb,
                position: [0, 0, -40]
            },
            development: {
                name: "ğŸ‘¶ ç™ºé”åŒº (éŸ“å›½é¢¨)",
                description: "èªçŸ¥ç™ºé”ã€æ„›ç€ã€ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ç ”ç©¶åœ°åŒºã€‚ã‚½ã‚¦ãƒ«ã®æ®µéšçš„ç™ºå±•ã‚’æ¨¡ã—ãŸå»ºç¯‰ç¾¤ã€‚",
                color: 0x98fb98,
                position: [40, 0, -40]
            },
            clinical: {
                name: "ğŸ¥ è‡¨åºŠåŒº (ã‚·ãƒ³ã‚¬ãƒãƒ¼ãƒ«é¢¨)",
                description: "ç²¾ç¥ç–¾æ‚£ã€å¿ƒç†ç™‚æ³•ã€ã‚¢ã‚»ã‚¹ãƒ¡ãƒ³ãƒˆã®åŒ»ç™‚åœ°åŒºã€‚æ¸…æ½”ã§å¤šæ–‡åŒ–ãªæ²»ç™‚ç’°å¢ƒã€‚",
                color: 0xffd700,
                position: [-40, 0, 0]
            },
            learning: {
                name: "ğŸ“š å­¦ç¿’åŒº (ã‚¿ã‚¤é¢¨)",
                description: "æ¡ä»¶ã¥ã‘ã€å¼·åŒ–ã€ç¤¾ä¼šå­¦ç¿’ã®ç ”ç©¶å¯ºé™¢ç¾¤ã€‚ãƒãƒ³ã‚³ã‚¯ã®é»„é‡‘å¯ºé™¢ã‚’ãƒ¢ãƒãƒ¼ãƒ•ã«ã—ãŸå­¦ç¿’ã®è–åœ°ã€‚",
                color: 0xffa500,
                position: [0, 0, 0]
            },
            social: {
                name: "ğŸ‘¥ ç¤¾ä¼šåŒº (ã‚¤ãƒ³ãƒ‰é¢¨)",
                description: "å¯¾äººèªçŸ¥ã€é›†å›£å¿ƒç†ã€æ…‹åº¦å¤‰åŒ–ã®å¤šæ§˜æ€§åœ°åŒºã€‚ãƒ ãƒ³ãƒã‚¤ã®ã‚«ãƒ©ãƒ•ãƒ«ã§å¤šæ–‡åŒ–ãªç¤¾ä¼šå®Ÿé¨“å ´ã€‚",
                color: 0xda70d6,
                position: [40, 0, 0]
            },
            personality: {
                name: "ğŸ’­ äººæ ¼åŒº (é¦™æ¸¯é¢¨)",
                description: "ç‰¹æ€§è«–ã€é˜²è¡›æ©Ÿåˆ¶ã€æ¸¬å®šæŠ€è¡“ã®å›½éš›é‡‘èéƒ½å¸‚ã€‚ç²¾å¯†ã§å¤šæ§˜ãªäººæ ¼ç‰¹æ€§ã‚’æ¸¬å®šã€‚",
                color: 0x40e0d0,
                position: [-40, 0, 40]
            },
            perception: {
                name: "ğŸ‘ï¸ çŸ¥è¦šåŒº (å°æ¹¾é¢¨)",
                description: "è¦–è¦šã€è´è¦šã€æ„Ÿè¦šèªçŸ¥ã®ç²¾å¯†æŠ€è¡“éƒ½å¸‚ã€‚å°åŒ—ã®ãƒã‚ªãƒ³è¡—ã®ã‚ˆã†ãªè¦–è¦šåˆºæ¿€ã«æº€ã¡ãŸç ”ç©¶åœ°ã€‚",
                color: 0xee82ee,
                position: [0, 0, 40]
            },
            neural: {
                name: "âš¡ ç¥çµŒåŒº (ãƒ™ãƒˆãƒŠãƒ é¢¨)",
                description: "è„³æ©Ÿèƒ½ã€ç¥çµŒç§‘å­¦ã€ç”Ÿç†å¿ƒç†å­¦ã®æœ€å‰ç·šç ”ç©¶åŸºåœ°ã€‚ãƒ›ãƒ¼ãƒãƒŸãƒ³ã®æ´»ç™ºãªè„³ç§‘å­¦ç ”ç©¶æ‰€ã€‚",
                color: 0x20b2aa,
                position: [40, 0, 40]
            }
        };

        function init() {
            // ã‚·ãƒ¼ãƒ³ã®ä½œæˆ
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x001122, 0.001);

            // ã‚«ãƒ¡ãƒ©ã®ä½œæˆ
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 80, 120);
            camera.lookAt(0, 0, 0);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä½œæˆ
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x001122, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);

            // é«˜å“è³ªãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
            setupAdvancedLighting();

            // é«˜å“è³ªåœ°é¢ã®ä½œæˆ
            createAdvancedGround();

            // ç©ºã®ä½œæˆ
            createSkybox();

            // ä¸­å¤®å¸‚åºèˆã®ä½œæˆ
            createCityHall();

            // å„åŒºåŸŸã®ä½œæˆ
            createDistricts();

            // é“è·¯ã®ä½œæˆ
            createRoads();

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰åˆ¶å¾¡ã®è¿½åŠ 
            addKeyboardControls();
            
            // é«˜åº¦ãªãƒã‚¦ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            addAdvancedMouseControls();

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            animate();
        }

        function setupAdvancedLighting() {
            // ç’°å¢ƒå…‰ï¼ˆå…¨ä½“çš„ãªæ˜ã‚‹ã•ï¼‰
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
            scene.add(ambientLight);

            // åŠçƒå…‰ï¼ˆç©ºã‹ã‚‰åœ°é¢ã¸ã®è‡ªç„¶ãªå…‰ï¼‰
            const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x362204, 0.4);
            scene.add(hemisphereLight);

            // ãƒ¡ã‚¤ãƒ³ã®å¤ªé™½å…‰
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(100, 200, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // è£œåŠ©å…‰ï¼ˆå»ºç‰©ã®é™°ã‚’å’Œã‚‰ã’ã‚‹ï¼‰
            const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.3);
            fillLight.position.set(-50, 50, -50);
            scene.add(fillLight);

            // ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆï¼ˆå„åŒºåŸŸã«è‰²ä»˜ããƒ©ã‚¤ãƒˆï¼‰
            const lightColors = [0xff69b4, 0x87ceeb, 0x98fb98, 0xffd700, 0xffa500, 0xda70d6, 0x40e0d0, 0xee82ee, 0x20b2aa];
            Object.keys(districtData).forEach((key, index) => {
                const district = districtData[key];
                const pointLight = new THREE.PointLight(lightColors[index] || 0xffffff, 0.6, 100);
                pointLight.position.set(district.position[0], 30, district.position[2]);
                pointLight.castShadow = true;
                pointLight.shadow.mapSize.width = 1024;
                pointLight.shadow.mapSize.height = 1024;
                scene.add(pointLight);
            });
        }

        function createAdvancedGround() {
            // é«˜å“è³ªåœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(400, 400, 100, 100);
            
            // åœ°é¢ç”¨ã®ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆç‰©ç†ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼‰
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d5016,
                roughness: 0.8,
                metalness: 0.1,
            });

            // é«˜ã•ãƒãƒƒãƒ—ã§èµ·ä¼ã‚’ä½œæˆ
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                vertices[i + 1] = Math.sin(x * 0.01) * Math.cos(z * 0.01) * 2;
            }
            groundGeometry.attributes.position.needsUpdate = true;
            groundGeometry.computeVertexNormals();

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // æ°´é¢ã®è¿½åŠ 
            const waterGeometry = new THREE.PlaneGeometry(300, 300);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.6,
                roughness: 0.1,
                metalness: 0.9,
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -2;
            scene.add(water);
        }

        function createSkybox() {
            // ç©ºã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077be) },
                    bottomColor: { value: new THREE.Color(0x89b2eb) },
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // é›²ã®è¿½åŠ 
            for (let i = 0; i < 20; i++) {
                const cloudGeometry = new THREE.SphereGeometry(
                    10 + Math.random() * 20, 
                    8, 
                    8
                );
                const cloudMaterial = new THREE.MeshLambertMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(
                    (Math.random() - 0.5) * 800,
                    100 + Math.random() * 100,
                    (Math.random() - 0.5) * 800
                );
                cloud.scale.x = 2;
                cloud.scale.z = 0.5;
                scene.add(cloud);
            }
        }

        function createCityHall() {
            // è¶…é«˜å“è³ªå¸‚åºèˆï¼ˆè¤‡é›‘ãªå½¢çŠ¶ï¼‰
            const group = new THREE.Group();
            
            // ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ¯ãƒ¼
            const mainGeometry = new THREE.CylinderGeometry(8, 12, 30, 16);
            const mainMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x221100,
                emissiveIntensity: 0.1
            });
            const mainTower = new THREE.Mesh(mainGeometry, mainMaterial);
            mainTower.position.y = 15;
            mainTower.castShadow = true;
            mainTower.receiveShadow = true;
            group.add(mainTower);

            // è¤‡æ•°ã®å‰¯ã‚¿ãƒ¯ãƒ¼
            for (let i = 0; i < 6; i++) {
                const subGeometry = new THREE.CylinderGeometry(3, 5, 15 + Math.random() * 10, 8);
                const subMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffaa00,
                    roughness: 0.4,
                    metalness: 0.6
                });
                const subTower = new THREE.Mesh(subGeometry, subMaterial);
                const angle = (i / 6) * Math.PI * 2;
                const radius = 15;
                subTower.position.set(
                    Math.cos(angle) * radius,
                    10,
                    Math.sin(angle) * radius
                );
                subTower.castShadow = true;
                subTower.receiveShadow = true;
                group.add(subTower);
            }

            // å±‹æ ¹ï¼ˆè¤‡é›‘ãªå½¢çŠ¶ï¼‰
            const roofGeometry = new THREE.ConeGeometry(10, 12, 16);
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0xff6600,
                roughness: 0.2,
                metalness: 0.8
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 36;
            roof.castShadow = true;
            group.add(roof);

            // è£…é£¾çš„ãªè¦ç´ 
            for (let i = 0; i < 12; i++) {
                const ornamentGeometry = new THREE.TetrahedronGeometry(1);
                const ornamentMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    emissive: 0x444400,
                    emissiveIntensity: 0.3
                });
                const ornament = new THREE.Mesh(ornamentGeometry, ornamentMaterial);
                const angle = (i / 12) * Math.PI * 2;
                ornament.position.set(
                    Math.cos(angle) * 8,
                    25 + Math.sin(i) * 2,
                    Math.sin(angle) * 8
                );
                ornament.castShadow = true;
                group.add(ornament);
            }

            scene.add(group);
            createLabel("ğŸ›ï¸ å¿ƒç†å­¦ä¸­å¤®æ”¿åºœ", 0, 45, 0);
        }

        function createDistricts() {
            Object.keys(districtData).forEach(key => {
                const district = districtData[key];
                const group = new THREE.Group();
                
                // è¶…é«˜å“è³ªãƒ¡ã‚¤ãƒ³ãƒ“ãƒ«ãƒ‡ã‚£ãƒ³ã‚°
                const mainBuilding = createHighQualityBuilding(district.color, 25, 8, 8, 'main');
                mainBuilding.position.set(0, 12.5, 0);
                group.add(mainBuilding);

                // è¤‡æ•°ã®é«˜å“è³ªã‚µãƒ–ãƒ“ãƒ«ãƒ‡ã‚£ãƒ³ã‚°
                const buildingStyles = ['tower', 'pyramid', 'dome', 'crystal', 'spiral', 'modern'];
                
                for (let i = 0; i < 8; i++) {
                    const height = 8 + Math.random() * 15;
                    const style = buildingStyles[i % buildingStyles.length];
                    const building = createHighQualityBuilding(district.color, height, 4, 4, style);
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = 12 + Math.random() * 8;
                    building.position.set(
                        Math.cos(angle) * radius,
                        height / 2,
                        Math.sin(angle) * radius
                    );
                    building.rotation.y = Math.random() * Math.PI;
                    group.add(building);
                }

                // ç‰¹æ®Šå»ºç¯‰ç‰©
                const specialBuilding = createSpecialArchitecture(key, district.color);
                specialBuilding.position.set(0, 0, -15);
                group.add(specialBuilding);

                // ç’°å¢ƒè£…é£¾
                createEnvironmentDetails(group, district.color);

                group.position.set(district.position[0], district.position[1], district.position[2]);
                scene.add(group);
                districts[key] = group;

                createLabel(district.name, district.position[0], 35, district.position[2]);
            });
        }

        function createHighQualityBuilding(color, height, width, depth, style = 'basic') {
            let geometry;
            
            switch(style) {
                case 'tower':
                    geometry = new THREE.CylinderGeometry(width * 0.7, width, height, 12);
                    break;
                case 'pyramid':
                    geometry = new THREE.ConeGeometry(width, height, 8);
                    break;
                case 'dome':
                    geometry = new THREE.SphereGeometry(width * 0.8, 16, 16);
                    break;
                case 'crystal':
                    geometry = new THREE.OctahedronGeometry(width);
                    break;
                case 'spiral':
                    geometry = new THREE.CylinderGeometry(width * 0.5, width, height, 16);
                    break;
                case 'modern':
                    geometry = new THREE.BoxGeometry(width, height, depth);
                    break;
                default:
                    geometry = new THREE.CylinderGeometry(width * 0.8, width, height, 8);
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3 + Math.random() * 0.4,
                metalness: 0.2 + Math.random() * 0.6,
                emissive: new THREE.Color(color).multiplyScalar(0.05),
                emissiveIntensity: 0.1
            });
            
            const building = new THREE.Mesh(geometry, material);
            building.castShadow = true;
            building.receiveShadow = true;
            
            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¿½åŠ 
            if (style !== 'crystal' && style !== 'dome') {
                addWindows(building, color, height, style);
            }
            
            return building;
        }

        function addWindows(building, color, height, style) {
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x87ceeb,
                emissive: 0x001122,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.9
            });

            const rows = Math.floor(height / 3);
            const cols = style === 'tower' ? 8 : 4;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    
                    const angle = (col / cols) * Math.PI * 2;
                    const radius = style === 'tower' ? 3.5 : 2.5;
                    
                    window.position.set(
                        Math.cos(angle) * radius,
                        (row - rows / 2) * 3,
                        Math.sin(angle) * radius
                    );
                    window.lookAt(0, window.position.y, 0);
                    building.add(window);
                }
            }
        }

        function createSpecialArchitecture(districtType, color) {
            const group = new THREE.Group();
            
            switch(districtType) {
                case 'statistics':
                    // ä¸­å›½é¢¨ãƒ‘ã‚´ãƒ€ï¼ˆè¤‡é›‘ãªå¤šå±¤æ§‹é€ ï¼‰
                    for (let i = 0; i < 5; i++) {
                        const level = new THREE.CylinderGeometry(6 - i, 7 - i, 3, 8);
                        const material = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(color).multiplyScalar(0.8 + i * 0.1),
                            roughness: 0.4,
                            metalness: 0.3
                        });
                        const mesh = new THREE.Mesh(level, material);
                        mesh.position.y = i * 3.5;
                        mesh.castShadow = true;
                        group.add(mesh);
                    }
                    break;
                    
                case 'cognitive':
                    // æ—¥æœ¬é¢¨ã®è¤‡é›‘ãªå¡”
                    const brainGeometry = new THREE.SphereGeometry(4, 16, 16);
                    const brainMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.6,
                        metalness: 0.2,
                        bumpScale: 0.1
                    });
                    const brain = new THREE.Mesh(brainGeometry, brainMaterial);
                    brain.position.y = 8;
                    brain.castShadow = true;
                    group.add(brain);
                    
                    // ç¥çµŒãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é¢¨ã®è£…é£¾
                    for (let i = 0; i < 20; i++) {
                        const neuronGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                        const neuronMaterial = new THREE.MeshStandardMaterial({
                            color: 0xffff00,
                            emissive: 0x444400,
                            emissiveIntensity: 0.5
                        });
                        const neuron = new THREE.Mesh(neuronGeometry, neuronMaterial);
                        neuron.position.set(
                            (Math.random() - 0.5) * 8,
                            4 + Math.random() * 8,
                            (Math.random() - 0.5) * 8
                        );
                        group.add(neuron);
                    }
                    break;
                    
                case 'development':
                    // éŸ“å›½é¢¨ã®æ®µéšå»ºç¯‰
                    for (let i = 0; i < 4; i++) {
                        const stageGeometry = new THREE.BoxGeometry(8 - i * 1.5, 4, 8 - i * 1.5);
                        const stageMaterial = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(color).multiplyScalar(0.7 + i * 0.1),
                            roughness: 0.5,
                            metalness: 0.4
                        });
                        const stage = new THREE.Mesh(stageGeometry, stageMaterial);
                        stage.position.y = i * 4 + 2;
                        stage.castShadow = true;
                        group.add(stage);
                    }
                    break;
                    
                case 'clinical':
                    // ã‚·ãƒ³ã‚¬ãƒãƒ¼ãƒ«é¢¨ã®ã‚¯ãƒªãƒ¼ãƒ³ãªåŒ»ç™‚å»ºç¯‰
                    const clinicalGeometry = new THREE.CylinderGeometry(5, 6, 16, 12);
                    const clinicalMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.2,
                        metalness: 0.8,
                        transparent: true,
                        opacity: 0.9
                    });
                    const clinical = new THREE.Mesh(clinicalGeometry, clinicalMaterial);
                    clinical.position.y = 8;
                    clinical.castShadow = true;
                    group.add(clinical);
                    
                    // åŒ»ç™‚åå­—ãƒãƒ¼ã‚¯
                    const crossMaterial = new THREE.MeshStandardMaterial({
                        color: 0xff0000,
                        emissive: 0x440000,
                        emissiveIntensity: 0.3
                    });
                    const crossH = new THREE.BoxGeometry(4, 0.5, 0.5);
                    const crossV = new THREE.BoxGeometry(0.5, 4, 0.5);
                    const cross1 = new THREE.Mesh(crossH, crossMaterial);
                    const cross2 = new THREE.Mesh(crossV, crossMaterial);
                    cross1.position.set(0, 16, 0);
                    cross2.position.set(0, 16, 0);
                    group.add(cross1);
                    group.add(cross2);
                    break;
                    
                case 'learning':
                    // ã‚¿ã‚¤é¢¨ã®é»„é‡‘å¯ºé™¢
                    const templeGeometry = new THREE.ConeGeometry(6, 20, 8);
                    const templeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffd700,
                        roughness: 0.1,
                        metalness: 0.9,
                        emissive: 0x332200,
                        emissiveIntensity: 0.2
                    });
                    const temple = new THREE.Mesh(templeGeometry, templeMaterial);
                    temple.position.y = 10;
                    temple.castShadow = true;
                    group.add(temple);
                    
                    // é»„é‡‘ã®è£…é£¾
                    for (let i = 0; i < 8; i++) {
                        const ornamentGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                        const ornamentMaterial = new THREE.MeshStandardMaterial({
                            color: 0xffff00,
                            emissive: 0x444400,
                            emissiveIntensity: 0.4
                        });
                        const ornament = new THREE.Mesh(ornamentGeometry, ornamentMaterial);
                        const angle = (i / 8) * Math.PI * 2;
                        ornament.position.set(
                            Math.cos(angle) * 7,
                            5 + Math.sin(i) * 2,
                            Math.sin(angle) * 7
                        );
                        group.add(ornament);
                    }
                    break;
                    
                case 'social':
                    // ã‚¤ãƒ³ãƒ‰é¢¨ã®å¤šæ–‡åŒ–å»ºç¯‰
                    const socialGeometry = new THREE.OctahedronGeometry(5);
                    const socialMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.4,
                        metalness: 0.5
                    });
                    const social = new THREE.Mesh(socialGeometry, socialMaterial);
                    social.position.y = 8;
                    social.castShadow = true;
                    group.add(social);
                    
                    // ã‚«ãƒ©ãƒ•ãƒ«ãªå¤šæ§˜æ€§ã®è¡¨ç¾
                    const diversityColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
                    for (let i = 0; i < 6; i++) {
                        const diversityGeometry = new THREE.BoxGeometry(1, 6, 1);
                        const diversityMaterial = new THREE.MeshStandardMaterial({
                            color: diversityColors[i],
                            emissive: diversityColors[i],
                            emissiveIntensity: 0.1
                        });
                        const diversity = new THREE.Mesh(diversityGeometry, diversityMaterial);
                        const angle = (i / 6) * Math.PI * 2;
                        diversity.position.set(
                            Math.cos(angle) * 8,
                            3,
                            Math.sin(angle) * 8
                        );
                        group.add(diversity);
                    }
                    break;
                    
                case 'personality':
                    // é¦™æ¸¯é¢¨ã®ã‚¹ã‚¿ã‚¤ãƒªãƒƒã‚·ãƒ¥ã‚¿ãƒ¯ãƒ¼
                    const personalityGeometry = new THREE.CylinderGeometry(3, 4, 18, 6);
                    const personalityMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.2,
                        metalness: 0.8,
                        transparent: true,
                        opacity: 0.8
                    });
                    const personality = new THREE.Mesh(personalityGeometry, personalityMaterial);
                    personality.position.y = 9;
                    personality.castShadow = true;
                    group.add(personality);
                    
                    // æ€§æ ¼ç‰¹æ€§ã®5ã¤ã®æŸ±ï¼ˆãƒ“ãƒƒã‚°ãƒ•ã‚¡ã‚¤ãƒ–ï¼‰
                    const traits = ['O', 'C', 'E', 'A', 'N'];
                    for (let i = 0; i < 5; i++) {
                        const traitGeometry = new THREE.CylinderGeometry(0.5, 0.5, 12, 8);
                        const traitMaterial = new THREE.MeshStandardMaterial({
                            color: new THREE.Color().setHSL(i * 0.2, 0.8, 0.6),
                            emissive: new THREE.Color().setHSL(i * 0.2, 0.8, 0.2),
                            emissiveIntensity: 0.2
                        });
                        const trait = new THREE.Mesh(traitGeometry, traitMaterial);
                        const angle = (i / 5) * Math.PI * 2;
                        trait.position.set(
                            Math.cos(angle) * 6,
                            6,
                            Math.sin(angle) * 6
                        );
                        group.add(trait);
                    }
                    break;
                    
                case 'perception':
                    // å°æ¹¾é¢¨ã®æŠ€è¡“å»ºç¯‰
                    const perceptionGeometry = new THREE.TetrahedronGeometry(5);
                    const perceptionMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.3,
                        metalness: 0.7,
                        transparent: true,
                        opacity: 0.7
                    });
                    const perception = new THREE.Mesh(perceptionGeometry, perceptionMaterial);
                    perception.position.y = 8;
                    perception.castShadow = true;
                    group.add(perception);
                    
                    // çŸ¥è¦šã®éŒ¯è¦–åŠ¹æœ
                    for (let i = 0; i < 12; i++) {
                        const illusionGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                        const illusionMaterial = new THREE.MeshStandardMaterial({
                            color: i % 2 === 0 ? 0xffffff : 0x000000,
                            emissive: i % 2 === 0 ? 0x444444 : 0x000000,
                            emissiveIntensity: 0.3
                        });
                        const illusion = new THREE.Mesh(illusionGeometry, illusionMaterial);
                        const angle = (i / 12) * Math.PI * 2;
                        illusion.position.set(
                            Math.cos(angle) * 8,
                            4 + Math.sin(i * 2) * 2,
                            Math.sin(angle) * 8
                        );
                        group.add(illusion);
                    }
                    break;
                    
                case 'neural':
                    // ãƒ™ãƒˆãƒŠãƒ é¢¨ã®ç¥çµŒç§‘å­¦ç ”ç©¶æ‰€
                    const neuralGeometry = new THREE.SphereGeometry(4, 16, 16);
                    const neuralMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.5,
                        metalness: 0.3,
                        transparent: true,
                        opacity: 0.8
                    });
                    const neural = new THREE.Mesh(neuralGeometry, neuralMaterial);
                    neural.position.y = 8;
                    neural.castShadow = true;
                    group.add(neural);
                    
                    // è„³æ³¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¡¨ç¾
                    for (let i = 0; i < 24; i++) {
                        const waveGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2 + Math.sin(i) * 2, 4);
                        const waveMaterial = new THREE.MeshStandardMaterial({
                            color: 0x00ffff,
                            emissive: 0x004444,
                            emissiveIntensity: 0.5
                        });
                        const wave = new THREE.Mesh(waveGeometry, waveMaterial);
                        const angle = (i / 24) * Math.PI * 2;
                        wave.position.set(
                            Math.cos(angle) * 6,
                            4 + Math.sin(i * 0.5) * 2,
                            Math.sin(angle) * 6
                        );
                        group.add(wave);
                    }
                    break;
                    
                default:
                    const defaultGeometry = new THREE.ConeGeometry(4, 12, 8);
                    const defaultMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.3,
                        metalness: 0.5
                    });
                    const defaultBuilding = new THREE.Mesh(defaultGeometry, defaultMaterial);
                    defaultBuilding.position.y = 6;
                    defaultBuilding.castShadow = true;
                    group.add(defaultBuilding);
            }
            
            return group;
        }

        function createEnvironmentDetails(group, color) {
            // é«˜å“è³ªãªè£…é£¾è¦ç´ 
            for (let i = 0; i < 6; i++) {
                // è¡—ç¯
                const lampGroup = new THREE.Group();
                
                const poleGeometry = new THREE.CylinderGeometry(0.2, 0.3, 8);
                const poleMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.8,
                    metalness: 0.9
                });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.y = 4;
                pole.castShadow = true;
                lampGroup.add(pole);
                
                const lightGeometry = new THREE.SphereGeometry(1, 12, 12);
                const lightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffff88,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.y = 8.5;
                lampGroup.add(light);
                
                const angle = (i / 6) * Math.PI * 2;
                const radius = 20 + Math.random() * 10;
                lampGroup.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                
                group.add(lampGroup);
            }
            
            // æ¤ç‰©ã‚„è£…é£¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            for (let i = 0; i < 12; i++) {
                const decorGeometry = new THREE.ConeGeometry(0.5, 4, 6);
                const decorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228b22,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const decoration = new THREE.Mesh(decorGeometry, decorMaterial);
                decoration.position.set(
                    (Math.random() - 0.5) * 40,
                    2,
                    (Math.random() - 0.5) * 40
                );
                decoration.castShadow = true;
                group.add(decoration);
            }
        }

        function createRoads() {
            // ç¾ã—ã„é“è·¯ã‚·ã‚¹ãƒ†ãƒ 
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.2
            });

            // ãƒ¡ã‚¤ãƒ³ç’°çŠ¶é“è·¯
            const ringGeometry = new THREE.RingGeometry(60, 64, 64);
            const ring = new THREE.Mesh(ringGeometry, roadMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            ring.receiveShadow = true;
            scene.add(ring);

            // æ”¾å°„çŠ¶ã®é“è·¯ï¼ˆå„åŒºåŸŸã‚’ç¹‹ãï¼‰
            const roadColors = [0xff69b4, 0x87ceeb, 0x98fb98, 0xffd700, 0xffa500, 0xda70d6, 0x40e0d0, 0xee82ee, 0x20b2aa];
            Object.keys(districtData).forEach((key, index) => {
                const district = districtData[key];
                const roadGeometry = new THREE.PlaneGeometry(4, 80);
                const coloredRoadMaterial = new THREE.MeshStandardMaterial({
                    color: roadColors[index] || 0x666666,
                    roughness: 0.6,
                    metalness: 0.3,
                    transparent: true,
                    opacity: 0.8
                });
                const road = new THREE.Mesh(roadGeometry, coloredRoadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.position.set(district.position[0] / 2, 0.2, district.position[2] / 2);
                road.lookAt(0, 0.2, 0);
                road.receiveShadow = true;
                scene.add(road);
            });

            // äº¤å·®ç‚¹
            const intersectionGeometry = new THREE.CylinderGeometry(8, 8, 0.5, 16);
            const intersectionMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.7,
                metalness: 0.4
            });
            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
            intersection.position.y = 0.25;
            intersection.receiveShadow = true;
            scene.add(intersection);
        }

        function createLabel(text, x, y, z) {
            // åŒºåŸŸãƒãƒ¼ã‚«ãƒ¼
            const markerGeometry = new THREE.ConeGeometry(1.5, 3, 8);
            const markerMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0x444400,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, y, z);
            marker.castShadow = true;
            scene.add(marker);

            // ãƒ‘ãƒ«ã‚¹åŠ¹æœã®ãŸã‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒãƒ¼ã‚«ãƒ¼ä¿å­˜
            marker.userData = { originalScale: marker.scale.clone(), pulseTime: Math.random() * Math.PI * 2 };
            if (!scene.userData.markers) scene.userData.markers = [];
            scene.userData.markers.push(marker);
        }

        function addAdvancedMouseControls() {
            let mouseDown = false;
            let mouseButton = 0;
            let mouseX = 0;
            let mouseY = 0;
            let mouseSensitivity = 0.002;

            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseButton = event.button;
                mouseX = event.clientX;
                mouseY = event.clientY;
                event.preventDefault();
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                if (viewMode === 'orbit') {
                    // è»Œé“ã‚«ãƒ¡ãƒ©ï¼ˆå¾“æ¥ã®å‹•ä½œï¼‰
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaX * mouseSensitivity;
                    spherical.phi += deltaY * mouseSensitivity;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                } else if (viewMode === 'fly' || viewMode === 'fps') {
                    // ãƒ•ãƒ©ã‚¤/FPSã‚«ãƒ¡ãƒ©
                    camera.rotation.y -= deltaX * mouseSensitivity;
                    camera.rotation.x -= deltaY * mouseSensitivity;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                }

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                if (viewMode === 'orbit') {
                    const distance = camera.position.length();
                    const newDistance = distance + event.deltaY * 0.01;
                    const clampedDistance = Math.max(10, Math.min(200, newDistance));
                    
                    camera.position.normalize().multiplyScalar(clampedDistance);
                    camera.lookAt(0, 0, 0);
                } else {
                    // ãƒ•ãƒ©ã‚¤/FPSãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚ºãƒ¼ãƒ ã§ã‚¹ãƒ”ãƒ¼ãƒ‰èª¿æ•´
                    flySpeed = Math.max(0.1, Math.min(5.0, flySpeed + event.deltaY * 0.001));
                }
                event.preventDefault();
            });

            // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯ï¼ˆFPSãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
            renderer.domElement.addEventListener('click', () => {
                if (viewMode === 'fps') {
                    renderer.domElement.requestPointerLock();
                }
            });
        }

        function addKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                
                // ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚­ãƒ¼
                switch(event.code) {
                    case 'Digit1': setViewMode('orbit'); break;
                    case 'Digit2': setViewMode('fly'); break;
                    case 'Digit3': setViewMode('fps'); break;
                    case 'KeyR': resetCamera(); break;
                    case 'KeyW': toggleWireframe(); break;
                    case 'KeyF': toggleFullscreen(); break;
                    case 'Escape': exitPointerLock(); break;
                }
            });

            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });
        }

        function updateCameraMovement() {
            if (viewMode === 'fly' || viewMode === 'fps') {
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                const up = new THREE.Vector3(0, 1, 0);
                
                forward.applyQuaternion(camera.quaternion);
                right.applyQuaternion(camera.quaternion);
                
                velocity.set(0, 0, 0);
                
                if (keys['KeyW']) velocity.add(forward.multiplyScalar(flySpeed));
                if (keys['KeyS']) velocity.add(forward.multiplyScalar(-flySpeed));
                if (keys['KeyA']) velocity.add(right.multiplyScalar(-flySpeed));
                if (keys['KeyD']) velocity.add(right.multiplyScalar(flySpeed));
                if (keys['Space']) velocity.add(up.multiplyScalar(flySpeed));
                if (keys['ShiftLeft']) velocity.add(up.multiplyScalar(-flySpeed));
                
                camera.position.add(velocity);
                
                // å¢ƒç•Œåˆ¶é™
                camera.position.x = Math.max(-150, Math.min(150, camera.position.x));
                camera.position.z = Math.max(-150, Math.min(150, camera.position.z));
                camera.position.y = Math.max(1, Math.min(150, camera.position.y));
            }
        }

        function setViewMode(mode) {
            viewMode = mode;
            updateInfo(`ğŸ¥ ${mode.toUpperCase()}ãƒ¢ãƒ¼ãƒ‰`, `ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ãŒ${mode}ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚`);
            
            if (mode === 'fps') {
                updateInfo(`ğŸ‘¤ FPSãƒ¢ãƒ¼ãƒ‰`, `WASD:ç§»å‹• ã‚¹ãƒšãƒ¼ã‚¹:ä¸Šæ˜‡ Shift:ä¸‹é™ ãƒã‚¦ã‚¹:è¦–ç‚¹å¤‰æ›´ ã‚¯ãƒªãƒƒã‚¯ã§ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯`);
            } else if (mode === 'fly') {
                updateInfo(`ğŸš ãƒ•ãƒ©ã‚¤ãƒ¢ãƒ¼ãƒ‰`, `WASD:ç§»å‹• ã‚¹ãƒšãƒ¼ã‚¹:ä¸Šæ˜‡ Shift:ä¸‹é™ ãƒã‚¦ã‚¹:è¦–ç‚¹å¤‰æ›´ ãƒ›ã‚¤ãƒ¼ãƒ«:ã‚¹ãƒ”ãƒ¼ãƒ‰èª¿æ•´`);
            } else {
                updateInfo(`ğŸŒ è»Œé“ãƒ¢ãƒ¼ãƒ‰`, `ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°:å›è»¢ ãƒ›ã‚¤ãƒ¼ãƒ«:ã‚ºãƒ¼ãƒ  è‡ªå‹•ã§ä¸­å¿ƒã‚’æ³¨è¦–`);
            }
        }

        function resetCamera() {
            camera.position.set(0, 80, 120);
            camera.rotation.set(0, 0, 0);
            camera.lookAt(0, 0, 0);
            viewMode = 'orbit';
            updateInfo("ğŸ¯ ã‚«ãƒ¡ãƒ©ãƒªã‚»ãƒƒãƒˆ", "ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’åˆæœŸçŠ¶æ…‹ã«æˆ»ã—ã¾ã—ãŸã€‚");
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            
            scene.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.wireframe = wireframeMode);
                    } else {
                        child.material.wireframe = wireframeMode;
                    }
                }
            });
            
            updateInfo("ğŸ“ ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ", `ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤º: ${wireframeMode ? 'ON' : 'OFF'}`);
        }

        function toggleFullscreen() {
            if (!isFullscreen) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
                isFullscreen = true;
                updateInfo("ğŸ–¥ï¸ å…¨ç”»é¢ãƒ¢ãƒ¼ãƒ‰", "å…¨ç”»é¢è¡¨ç¤ºã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚ESCã‚­ãƒ¼ã§çµ‚äº†ã§ãã¾ã™ã€‚");
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                isFullscreen = false;
                updateInfo("ğŸªŸ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ¢ãƒ¼ãƒ‰", "ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºã«æˆ»ã‚Šã¾ã—ãŸã€‚");
            }
        }

        function exitPointerLock() {
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }

        function focusDistrict(districtKey) {
            if (districtKey === 'overview') {
                camera.position.set(0, 100, 150);
                camera.lookAt(0, 0, 0);
                updateInfo("ğŸŒ† å…¨ä½“è¡¨ç¤º", "å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£å…¨ä½“ã‚’ä¿¯ç°è¡¨ç¤ºã€‚å„åŒºåŸŸãŒæœ‰æ©Ÿçš„ã«é€£æºã—ã¦ã„ã‚‹æ§˜å­ã‚’ç¢ºèªã§ãã¾ã™ã€‚9ã¤ã®å¿ƒç†å­¦åˆ†é‡ãŒç¾ã—ãé…ç½®ã•ã‚Œã¦ã„ã¾ã™ã€‚");
                return;
            }

            const district = districtData[districtKey];
            if (district) {
                camera.position.set(
                    district.position[0] + 30,
                    40,
                    district.position[2] + 30
                );
                camera.lookAt(district.position[0], 0, district.position[2]);
                updateInfo(district.name, district.description);
            }
        }

        function updateInfo(title, description) {
            const infoDiv = document.getElementById('district-info');
            infoDiv.innerHTML = `<strong>${title}</strong><br>${description}<br><em>ãƒã‚¦ã‚¹ã§å›è»¢ã€ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ </em>`;
        }

        function animate() {
            requestAnimationFrame(animate);

            // ã‚«ãƒ¡ãƒ©ç§»å‹•ã®æ›´æ–°
            updateCameraMovement();

            // æ™‚é–“ãƒ™ãƒ¼ã‚¹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            const time = Date.now() * 0.001;

            // å»ºç‰©ã®è»½ã„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå‘¼å¸ã™ã‚‹ã‚ˆã†ãªå‹•ãï¼‰
            Object.keys(districts).forEach((key, index) => {
                const district = districts[key];
                if (district) {
                    district.children.forEach((building, buildingIndex) => {
                        if (buildingIndex > 0) { // ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ«ãƒ‡ã‚£ãƒ³ã‚°ä»¥å¤–
                            const originalY = building.userData.originalY || building.position.y;
                            building.userData.originalY = originalY;
                            building.position.y = originalY + Math.sin(time * 2 + index + buildingIndex) * 0.3;
                        }
                        
                        // å»ºç‰©ã®å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç‰¹æ®Šå»ºç¯‰ç‰©ï¼‰
                        if (buildingIndex === 0 && building.children.length > 0) {
                            building.rotation.y += 0.005;
                        }
                    });
                }
            });

            // ãƒãƒ¼ã‚«ãƒ¼ã®ãƒ‘ãƒ«ã‚¹åŠ¹æœ
            if (scene.userData.markers) {
                scene.userData.markers.forEach((marker, index) => {
                    const pulseTime = marker.userData.pulseTime + time;
                    const scale = 1 + Math.sin(pulseTime * 3) * 0.2;
                    marker.scale.setScalar(scale);
                    marker.rotation.y += 0.02;
                });
            }

            // é›²ã®ç§»å‹•
            scene.traverse((child) => {
                if (child.isMesh && child.position.y > 50 && child.material.opacity < 1) {
                    child.position.x += Math.sin(time * 0.1 + child.position.z * 0.01) * 0.1;
                    child.position.z += Math.cos(time * 0.1 + child.position.x * 0.01) * 0.1;
                    child.rotation.y += 0.001;
                }
            });

            // æ°´é¢ã®æ³¢ç´‹åŠ¹æœ
            scene.traverse((child) => {
                if (child.isMesh && child.position.y < 0 && child.material.opacity < 1) {
                    const vertices = child.geometry.attributes.position.array;
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i];
                        const z = vertices[i + 2];
                        vertices[i + 1] = Math.sin(time * 2 + x * 0.1) * Math.cos(time * 2 + z * 0.1) * 0.5;
                    }
                    child.geometry.attributes.position.needsUpdate = true;
                }
            });

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœï¼ˆå…‰ã®ç²’å­ï¼‰
            createParticleEffects(time);

            renderer.render(scene, camera);
        }

        function createParticleEffects(time) {
            // æ—¢å­˜ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
            if (scene.userData.particles) {
                scene.userData.particles.forEach(particle => {
                    scene.remove(particle);
                });
                scene.userData.particles = [];
            } else {
                scene.userData.particles = [];
            }

            // æ–°ã—ã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆ
            for (let i = 0; i < 50; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: Math.random() * 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.set(
                    (Math.random() - 0.5) * 200,
                    Math.random() * 100 + 20,
                    (Math.random() - 0.5) * 200
                );
                
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.2
                );
                
                scene.add(particle);
                scene.userData.particles.push(particle);
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç§»å‹•
            scene.userData.particles.forEach((particle, index) => {
                particle.position.add(particle.userData.velocity);
                particle.rotation.x += 0.01;
                particle.rotation.y += 0.01;
                
                // å¢ƒç•Œã‚’è¶…ãˆãŸã‚‰å†é…ç½®
                if (particle.position.length() > 150) {
                    particle.position.set(
                        (Math.random() - 0.5) * 50,
                        Math.random() * 50 + 20,
                        (Math.random() - 0.5) * 50
                    );
                }
            });
        }

        function downloadHTML() {
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html; charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£3D.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            updateInfo("ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†", "å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£3Dã®HTMLãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸï¼");
        }

        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³å¤‰æ›´ã®æ¤œå‡º
        document.addEventListener('fullscreenchange', () => {
            isFullscreen = !!document.fullscreenElement;
        });

        // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯å¤‰æ›´ã®æ¤œå‡º
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === renderer.domElement) {
                updateInfo("ğŸ”’ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯", "FPSãƒ¢ãƒ¼ãƒ‰ã§ãƒã‚¦ã‚¹ãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸã€‚ESCã§è§£é™¤ã§ãã¾ã™ã€‚");
            } else {
                updateInfo("ğŸ”“ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯è§£é™¤", "ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯ãŒè§£é™¤ã•ã‚Œã¾ã—ãŸã€‚");
            }
        });

        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();

        // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        setTimeout(() => {
            updateInfo("ğŸŒŸ å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£ã¸ã‚ˆã†ã“ãï¼", "9ã¤ã®å¿ƒç†å­¦åˆ†é‡ãŒç¾ã—ã„3Déƒ½å¸‚ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚å„åŒºåŸŸã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ¢ç´¢ã—ã¾ã—ã‚‡ã†ï¼");
        }, 1000);
    </script>
</body>
</html>