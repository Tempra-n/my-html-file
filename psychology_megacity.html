<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£ 3D - Psychology Megacity</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #001122, #003366, #004488);
            font-family: 'Roboto', 'Arial', sans-serif;
            overflow: hidden;
            cursor: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: #00ffff;
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 350px;
            z-index: 100;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: #00ff00;
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .district-button {
            background: linear-gradient(135deg, #1e3c72, #2a5298, #667eea);
            color: #ffffff;
            border: 2px solid #00ffff;
            padding: 12px 18px;
            margin: 4px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 255, 255, 0.3);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .district-button:hover {
            transform: scale(1.1) translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 255, 255, 0.6);
            background: linear-gradient(135deg, #667eea, #764ba2, #a8e6cf);
            border-color: #ffffff;
        }
        
        #download-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24, #ff3838);
            color: white;
            border: 2px solid #ffffff;
            padding: 15px 25px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            transition: all 0.3s ease;
            box-shadow: 0 6px 12px rgba(255, 107, 107, 0.4);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        #download-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 16px rgba(255, 107, 107, 0.6);
        }
        
        #legend {
            position: absolute;
            top: 80px;
            right: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: #ffff00;
            padding: 20px;
            border-radius: 15px;
            font-size: 12px;
            max-width: 220px;
            z-index: 100;
            border: 2px solid #ffff00;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        #camera-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: #ff69b4;
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            border: 2px solid #ff69b4;
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.5);
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .camera-button {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            border: 1px solid #ffffff;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .camera-button:hover {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            transform: scale(1.05);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <button id="download-btn" onclick="downloadHTML()">ğŸ“¥ HTMLãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        
        <div id="info">
            <h3>ğŸŒ† å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£</h3>
            <div id="district-info">
                <strong>çµ±è¨ˆåŒº (ä¸­å›½é¢¨)</strong><br>
                è¨˜è¿°çµ±è¨ˆã€æ¨æ¸¬çµ±è¨ˆã€å¤šå¤‰é‡è§£æã®ä¸­å¿ƒåœ°<br>
                <em>ãƒã‚¦ã‚¹ã§å›è»¢ã€ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ </em>
            </div>
        </div>
        
        <div id="camera-controls">
            <h4>ğŸ¥ ã‚«ãƒ¡ãƒ©åˆ¶å¾¡</h4>
            <button class="camera-button" onclick="setViewMode('orbit')">ğŸŒ è»Œé“ã‚«ãƒ¡ãƒ©</button>
            <button class="camera-button" onclick="setViewMode('fly')">ğŸš ãƒ•ãƒ©ã‚¤ã‚«ãƒ¡ãƒ©</button>
            <button class="camera-button" onclick="setViewMode('fps')">ğŸ‘¤ FPSã‚«ãƒ¡ãƒ©</button><br>
            <button class="camera-button" onclick="resetCamera()">ğŸ¯ ãƒªã‚»ãƒƒãƒˆ</button>
            <button class="camera-button" onclick="toggleWireframe()">ğŸ“ ãƒ¯ã‚¤ãƒ¤ãƒ¼</button>
            <button class="camera-button" onclick="toggleFullscreen()">ğŸ–¥ï¸ å…¨ç”»é¢</button>
        </div>
        
        <div id="legend">
            <h4>ğŸ˜ï¸ åŒºåŸŸå‡¡ä¾‹</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffb3d9;"></div>
                <span>ğŸ“Š çµ±è¨ˆåŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #b3e0ff;"></div>
                <span>ğŸ§  èªçŸ¥åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ccffcc;"></div>
                <span>ğŸ‘¶ ç™ºé”åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fff2b3;"></div>
                <span>ğŸ¥ è‡¨åºŠåŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffd9b3;"></div>
                <span>ğŸ“š å­¦ç¿’åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f0b3ff;"></div>
                <span>ğŸ‘¥ ç¤¾ä¼šåŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #b3fff0;"></div>
                <span>ğŸ’­ äººæ ¼åŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffccf2;"></div>
                <span>ğŸ‘ï¸ çŸ¥è¦šåŒº</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ccf2ff;"></div>
                <span>âš¡ ç¥çµŒåŒº</span>
            </div>
        </div>
        
        <div id="controls">
            <h4>ğŸ® åŒºåŸŸé¸æŠ</h4>
            <button class="district-button" onclick="focusDistrict('statistics')">ğŸ“Š çµ±è¨ˆåŒº</button>
            <button class="district-button" onclick="focusDistrict('cognitive')">ğŸ§  èªçŸ¥åŒº</button>
            <button class="district-button" onclick="focusDistrict('development')">ğŸ‘¶ ç™ºé”åŒº</button>
            <button class="district-button" onclick="focusDistrict('clinical')">ğŸ¥ è‡¨åºŠåŒº</button><br>
            <button class="district-button" onclick="focusDistrict('learning')">ğŸ“š å­¦ç¿’åŒº</button>
            <button class="district-button" onclick="focusDistrict('social')">ğŸ‘¥ ç¤¾ä¼šåŒº</button>
            <button class="district-button" onclick="focusDistrict('personality')">ğŸ’­ äººæ ¼åŒº</button>
            <button class="district-button" onclick="focusDistrict('perception')">ğŸ‘ï¸ çŸ¥è¦šåŒº</button><br>
            <button class="district-button" onclick="focusDistrict('neural')">âš¡ ç¥çµŒåŒº</button>
            <button class="district-button" onclick="focusDistrict('overview')">ğŸŒ† å…¨ä½“è¡¨ç¤º</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®åˆæœŸåŒ–
        let scene, camera, renderer;
        let districts = {};
        let currentDistrict = null;
        
        // 3DCGæ‹¡å¼µå¤‰æ•°
        let viewMode = 'orbit';
        let keys = {};
        let wireframeMode = false;
        let isFullscreen = false;
        let velocity = new THREE.Vector3();
        let moveSpeed = 0.5;
        let flySpeed = 1.0;
        
        // åŒºåŸŸæƒ…å ±ï¼ˆå¯æ„›ã„ãƒ‘ã‚¹ãƒ†ãƒ«ï¼†é€æ˜æ„Ÿã®ã‚ã‚‹è‰²ï¼‰
        const districtData = {
            statistics: {
                name: "ğŸ“Š çµ±è¨ˆåŒº (ä¸­å›½é¢¨)",
                description: "è¨˜è¿°çµ±è¨ˆã€æ¨æ¸¬çµ±è¨ˆã€å¤šå¤‰é‡è§£æã®ç ”ç©¶ä¸­å¿ƒåœ°ã€‚ä¸Šæµ·ã®é‡‘èè¡—ã®ã‚ˆã†ãªé«˜å±¤ãƒ“ãƒ«ç¾¤ã§æ•°å€¤ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ã€‚",
                color: 0xffb3d9, // å¯æ„›ã„ãƒ”ãƒ³ã‚¯ï¼ˆé€æ˜æ„Ÿï¼‰
                position: [-40, 0, -40]
            },
            cognitive: {
                name: "ğŸ§  èªçŸ¥åŒº (æ—¥æœ¬é¢¨)",
                description: "è¨˜æ†¶ã€æ³¨æ„ã€å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã®ç ”ç©¶ã‚¨ãƒªã‚¢ã€‚æ±äº¬ã®é›»å­å›è·¯ã®ã‚ˆã†ãªé“è·¯ç¶²ã§èªçŸ¥ãƒ—ãƒ­ã‚»ã‚¹ã‚’è¡¨ç¾ã€‚",
                color: 0xb3e0ff, // æ·¡ã„ç©ºè‰²ï¼ˆé€æ˜æ„Ÿï¼‰
                position: [0, 0, -40]
            },
            development: {
                name: "ğŸ‘¶ ç™ºé”åŒº (éŸ“å›½é¢¨)",
                description: "èªçŸ¥ç™ºé”ã€æ„›ç€ã€ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ç ”ç©¶åœ°åŒºã€‚ã‚½ã‚¦ãƒ«ã®æ®µéšçš„ç™ºå±•ã‚’æ¨¡ã—ãŸå»ºç¯‰ç¾¤ã€‚",
                color: 0xccffcc, // å„ªã—ã„ãƒŸãƒ³ãƒˆã‚°ãƒªãƒ¼ãƒ³
                position: [40, 0, -40]
            },
            clinical: {
                name: "ğŸ¥ è‡¨åºŠåŒº (ã‚·ãƒ³ã‚¬ãƒãƒ¼ãƒ«é¢¨)",
                description: "ç²¾ç¥ç–¾æ‚£ã€å¿ƒç†ç™‚æ³•ã€ã‚¢ã‚»ã‚¹ãƒ¡ãƒ³ãƒˆã®åŒ»ç™‚åœ°åŒºã€‚æ¸…æ½”ã§å¤šæ–‡åŒ–ãªæ²»ç™‚ç’°å¢ƒã€‚",
                color: 0xfff2b3, // å„ªã—ã„ã‚¯ãƒªãƒ¼ãƒ è‰²
                position: [-40, 0, 0]
            },
            learning: {
                name: "ğŸ“š å­¦ç¿’åŒº (ã‚¿ã‚¤é¢¨)",
                description: "æ¡ä»¶ã¥ã‘ã€å¼·åŒ–ã€ç¤¾ä¼šå­¦ç¿’ã®ç ”ç©¶å¯ºé™¢ç¾¤ã€‚ãƒãƒ³ã‚³ã‚¯ã®é»„é‡‘å¯ºé™¢ã‚’ãƒ¢ãƒãƒ¼ãƒ•ã«ã—ãŸå­¦ç¿’ã®è–åœ°ã€‚",
                color: 0xffd9b3, // æ¸©ã‹ã„ãƒ”ãƒ¼ãƒè‰²
                position: [0, 0, 0]
            },
            social: {
                name: "ğŸ‘¥ ç¤¾ä¼šåŒº (ã‚¤ãƒ³ãƒ‰é¢¨)",
                description: "å¯¾äººèªçŸ¥ã€é›†å›£å¿ƒç†ã€æ…‹åº¦å¤‰åŒ–ã®å¤šæ§˜æ€§åœ°åŒºã€‚ãƒ ãƒ³ãƒã‚¤ã®ã‚«ãƒ©ãƒ•ãƒ«ã§å¤šæ–‡åŒ–ãªç¤¾ä¼šå®Ÿé¨“å ´ã€‚",
                color: 0xf0b3ff, // å¯æ„›ã„ãƒ©ãƒ™ãƒ³ãƒ€ãƒ¼
                position: [40, 0, 0]
            },
            personality: {
                name: "ğŸ’­ äººæ ¼åŒº (é¦™æ¸¯é¢¨)",
                description: "ç‰¹æ€§è«–ã€é˜²è¡›æ©Ÿåˆ¶ã€æ¸¬å®šæŠ€è¡“ã®å›½éš›é‡‘èéƒ½å¸‚ã€‚ç²¾å¯†ã§å¤šæ§˜ãªäººæ ¼ç‰¹æ€§ã‚’æ¸¬å®šã€‚",
                color: 0xb3fff0, // é€æ˜æ„Ÿã®ã‚ã‚‹ã‚¢ã‚¯ã‚¢
                position: [-40, 0, 40]
            },
            perception: {
                name: "ğŸ‘ï¸ çŸ¥è¦šåŒº (å°æ¹¾é¢¨)",
                description: "è¦–è¦šã€è´è¦šã€æ„Ÿè¦šèªçŸ¥ã®ç²¾å¯†æŠ€è¡“éƒ½å¸‚ã€‚å°åŒ—ã®ãƒã‚ªãƒ³è¡—ã®ã‚ˆã†ãªè¦–è¦šåˆºæ¿€ã«æº€ã¡ãŸç ”ç©¶åœ°ã€‚",
                color: 0xffccf2, // ç”˜ã„ãƒ­ãƒ¼ã‚ºãƒ”ãƒ³ã‚¯
                position: [0, 0, 40]
            },
            neural: {
                name: "âš¡ ç¥çµŒåŒº (ãƒ™ãƒˆãƒŠãƒ é¢¨)",
                description: "è„³æ©Ÿèƒ½ã€ç¥çµŒç§‘å­¦ã€ç”Ÿç†å¿ƒç†å­¦ã®æœ€å‰ç·šç ”ç©¶åŸºåœ°ã€‚ãƒ›ãƒ¼ãƒãƒŸãƒ³ã®æ´»ç™ºãªè„³ç§‘å­¦ç ”ç©¶æ‰€ã€‚",
                color: 0xccf2ff, // é€æ˜æ„Ÿã®ã‚ã‚‹ã‚·ã‚¢ãƒ³
                position: [40, 0, 40]
            }
        };

        function init() {
            // ã‚·ãƒ¼ãƒ³ã®ä½œæˆ
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x001122, 0.0005); // ãƒ•ã‚©ã‚°ã‚’è–„ãã—ã¦è¦‹ã‚„ã™ã

            // ã‚«ãƒ¡ãƒ©ã®ä½œæˆï¼ˆåˆæœŸä½ç½®ã‚’èª¿æ•´ï¼‰
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 50, 100); // ã‚ˆã‚Šè¿‘ã„ä½ç½®ã«è¨­å®š
            camera.lookAt(0, 0, 0);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä½œæˆ
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x87ceeb, 1); // æ˜ã‚‹ã„ç©ºã®è‰²ã«å¤‰æ›´
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; // éœ²å‡ºã‚’ä¸‹ã’ã¦æ˜ã‚‹ã
            document.getElementById('container').appendChild(renderer.domElement);

            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šåº§æ¨™è»¸ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’è¿½åŠ 
            const axesHelper = new THREE.AxesHelper(50);
            scene.add(axesHelper);

            // æ˜ã‚‹ã„ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
            setupBrightLighting();

            // æ˜ã‚‹ã„åœ°é¢ã®ä½œæˆ
            createBrightGround();

            // æ˜ã‚‹ã„ç©ºã®ä½œæˆ
            createBrightSky();

            // ä¸­å¤®å¸‚åºèˆã®ä½œæˆ
            createCityHall();

            // å„åŒºåŸŸã®ä½œæˆ
            createDistricts();

            // é“è·¯ã®ä½œæˆ
            createRoads();

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰åˆ¶å¾¡ã®è¿½åŠ 
            addKeyboardControls();
            
            // é«˜åº¦ãªãƒã‚¦ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            addAdvancedMouseControls();

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            animate();

            // ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¡¨ç¤º
            console.log("Scene children count:", scene.children.length);
            console.log("Camera position:", camera.position);
        }

        function setupBrightLighting() {
            // æ˜ã‚‹ã„ç’°å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // ã‚ˆã‚Šæ˜ã‚‹ã
            scene.add(ambientLight);

            // æ˜ã‚‹ã„åŠçƒå…‰
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
            scene.add(hemisphereLight);

            // ãƒ¡ã‚¤ãƒ³ã®å¤ªé™½å…‰ï¼ˆã‚ˆã‚Šæ˜ã‚‹ãï¼‰
            const sunLight = new THREE.DirectionalLight(0xffffff, 2.0); // å¼·åº¦ã‚’ä¸Šã’ã‚‹
            sunLight.position.set(50, 100, 50); // ã‚ˆã‚Šè¿‘ã„ä½ç½®
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // è¿½åŠ ã®æ˜ã‚‹ã„ãƒ©ã‚¤ãƒˆ
            const fillLight = new THREE.DirectionalLight(0xffffff, 1.0);
            fillLight.position.set(-30, 50, -30);
            scene.add(fillLight);

            // ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆï¼ˆå„åŒºåŸŸã«æ˜ã‚‹ã„è‰²ä»˜ããƒ©ã‚¤ãƒˆï¼‰
            const lightColors = [0xffb3d9, 0xb3e0ff, 0xccffcc, 0xfff2b3, 0xffd9b3, 0xf0b3ff, 0xb3fff0, 0xffccf2, 0xccf2ff];
            Object.keys(districtData).forEach((key, index) => {
                const district = districtData[key];
                const pointLight = new THREE.PointLight(lightColors[index] || 0xffffff, 1.5, 200); // ã‚ˆã‚Šå¼·ãã€ç¯„å›²ã‚‚åºƒã
                pointLight.position.set(district.position[0], 50, district.position[2]);
                pointLight.castShadow = false; // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚
                scene.add(pointLight);
            });
        }

        function createBrightGround() {
            // æ˜ã‚‹ã„åœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            
            // æ˜ã‚‹ã„åœ°é¢ç”¨ã®ãƒãƒ†ãƒªã‚¢ãƒ«
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xc8e6c9, // æ˜ã‚‹ã„ã‚»ãƒ¼ã‚¸ã‚°ãƒªãƒ¼ãƒ³
                roughness: 0.8,
                metalness: 0.1,
            });

            // è»½ã„èµ·ä¼ã‚’ä½œæˆ
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                vertices[i + 1] = Math.sin(x * 0.02) * Math.cos(z * 0.02) * 1;
            }
            groundGeometry.attributes.position.needsUpdate = true;
            groundGeometry.computeVertexNormals();

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            console.log("Ground added to scene");
        }

        function createBrightSky() {
            // æ˜ã‚‹ã„ç©ºã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            const skyGeometry = new THREE.SphereGeometry(500, 16, 16);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x87ceeb) }, // æ˜ã‚‹ã„ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼
                    bottomColor: { value: new THREE.Color(0xe0f6ff) }, // æ·¡ã„ãƒ–ãƒ«ãƒ¼
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            console.log("Sky added to scene");
        }

        function createCityHall() {
            // æ˜ã‚‹ã„å¸‚åºèˆï¼ˆè¦‹ã‚„ã™ã„ã‚µã‚¤ã‚ºã«ï¼‰
            const group = new THREE.Group();
            
            // ãƒ¡ã‚¤ãƒ³ã‚¿ãƒ¯ãƒ¼ï¼ˆã‚ˆã‚Šå¤§ããï¼‰
            const mainGeometry = new THREE.CylinderGeometry(6, 8, 20, 16);
            const mainMaterial = new THREE.MeshStandardMaterial({
                color: 0xffeaa7, // æ˜ã‚‹ã„ã‚´ãƒ¼ãƒ«ãƒ‰
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x332211,
                emissiveIntensity: 0.2
            });
            const mainTower = new THREE.Mesh(mainGeometry, mainMaterial);
            mainTower.position.y = 10;
            mainTower.castShadow = true;
            mainTower.receiveShadow = true;
            group.add(mainTower);

            // å±‹æ ¹
            const roofGeometry = new THREE.ConeGeometry(8, 8, 16);
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0xff9ff3, // å¯æ„›ã„ãƒã‚¼ãƒ³ã‚¿
                roughness: 0.2,
                metalness: 0.8
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 24;
            roof.castShadow = true;
            group.add(roof);

            scene.add(group);
            createLabel("ğŸ›ï¸ å¿ƒç†å­¦ä¸­å¤®æ”¿åºœ", 0, 35, 0);
            
            console.log("City Hall added to scene at position:", group.position);
        }

        function createDistricts() {
            Object.keys(districtData).forEach(key => {
                const district = districtData[key];
                const group = new THREE.Group();
                
                // ã‚·ãƒ³ãƒ—ãƒ«ã§è¦‹ã‚„ã™ã„ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ«ãƒ‡ã‚£ãƒ³ã‚°
                const mainBuilding = createSimpleBuilding(district.color, 20, 6, 6);
                mainBuilding.position.set(0, 10, 0);
                group.add(mainBuilding);

                // ã‚µãƒ–ãƒ“ãƒ«ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆå°‘ãªãã—ã¦è¦‹ã‚„ã™ãï¼‰
                for (let i = 0; i < 4; i++) {
                    const height = 8 + Math.random() * 8;
                    const building = createSimpleBuilding(district.color, height, 3, 3);
                    const angle = (i / 4) * Math.PI * 2;
                    const radius = 8;
                    building.position.set(
                        Math.cos(angle) * radius,
                        height / 2,
                        Math.sin(angle) * radius
                    );
                    group.add(building);
                }

                // ç‰¹æ®Šå»ºç¯‰ç‰©ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
                const specialBuilding = createSimpleSpecialBuilding(key, district.color);
                specialBuilding.position.set(0, 0, -10);
                group.add(specialBuilding);

                group.position.set(district.position[0], district.position[1], district.position[2]);
                scene.add(group);
                districts[key] = group;

                createLabel(district.name, district.position[0], 25, district.position[2]);
                
                console.log(`District ${key} added at position:`, district.position);
            });
        }

        function createSimpleBuilding(color, height, width, depth) {
            const geometry = new THREE.CylinderGeometry(width * 0.8, width, height, 8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.5,
                transparent: true,
                opacity: 0.9
            });
            
            const building = new THREE.Mesh(geometry, material);
            building.castShadow = true;
            building.receiveShadow = true;
            
            return building;
        }

        function createSimpleSpecialBuilding(districtType, color) {
            const group = new THREE.Group();
            
            switch(districtType) {
                case 'statistics':
                    // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ”ãƒ³ã‚¯ã‚¿ãƒ¯ãƒ¼
                    const statsGeometry = new THREE.ConeGeometry(4, 12, 8);
                    const statsMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffb3d9,
                        transparent: true,
                        opacity: 0.9
                    });
                    const stats = new THREE.Mesh(statsGeometry, statsMaterial);
                    stats.position.y = 6;
                    stats.castShadow = true;
                    group.add(stats);
                    break;
                    
                case 'cognitive':
                    // ã‚·ãƒ³ãƒ—ãƒ«ãªè„³å‹
                    const brainGeometry = new THREE.SphereGeometry(3, 12, 12);
                    const brainMaterial = new THREE.MeshStandardMaterial({
                        color: 0xb3e0ff,
                        transparent: true,
                        opacity: 0.9
                    });
                    const brain = new THREE.Mesh(brainGeometry, brainMaterial);
                    brain.position.y = 5;
                    brain.castShadow = true;
                    group.add(brain);
                    break;
                    
                default:
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å»ºç‰©
                    const defaultGeometry = new THREE.BoxGeometry(4, 8, 4);
                    const defaultMaterial = new THREE.MeshStandardMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.9
                    });
                    const defaultBuilding = new THREE.Mesh(defaultGeometry, defaultMaterial);
                    defaultBuilding.position.y = 4;
                    defaultBuilding.castShadow = true;
                    group.add(defaultBuilding);
            }
            
            return group;
        }

        function createHighQualityBuilding(color, height, width, depth, style = 'basic') {
            let geometry;
            
            switch(style) {
                case 'tower':
                    geometry = new THREE.CylinderGeometry(width * 0.7, width, height, 12);
                    break;
                case 'pyramid':
                    geometry = new THREE.ConeGeometry(width, height, 8);
                    break;
                case 'dome':
                    geometry = new THREE.SphereGeometry(width * 0.8, 16, 16);
                    break;
                case 'crystal':
                    geometry = new THREE.OctahedronGeometry(width);
                    break;
                case 'spiral':
                    geometry = new THREE.CylinderGeometry(width * 0.5, width, height, 16);
                    break;
                case 'modern':
                    geometry = new THREE.BoxGeometry(width, height, depth);
                    break;
                default:
                    geometry = new THREE.CylinderGeometry(width * 0.8, width, height, 8);
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3 + Math.random() * 0.4,
                metalness: 0.2 + Math.random() * 0.6,
                emissive: new THREE.Color(color).multiplyScalar(0.05),
                emissiveIntensity: 0.1,
                transparent: true,
                opacity: 0.85 + Math.random() * 0.15 // é€æ˜æ„Ÿã®ã‚ã‚‹ãƒ©ãƒ³ãƒ€ãƒ å€¤
            });
            
            const building = new THREE.Mesh(geometry, material);
            building.castShadow = true;
            building.receiveShadow = true;
            
            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®è¿½åŠ 
            if (style !== 'crystal' && style !== 'dome') {
                addWindows(building, color, height, style);
            }
            
            return building;
        }

        function addWindows(building, color, height, style) {
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0xe1f5fe, // é€æ˜æ„Ÿã®ã‚ã‚‹æ·¡ã„ãƒ–ãƒ«ãƒ¼
                emissive: 0x001a33,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.6,
                roughness: 0.1,
                metalness: 0.9
            });

            const rows = Math.floor(height / 3);
            const cols = style === 'tower' ? 8 : 4;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    
                    const angle = (col / cols) * Math.PI * 2;
                    const radius = style === 'tower' ? 3.5 : 2.5;
                    
                    window.position.set(
                        Math.cos(angle) * radius,
                        (row - rows / 2) * 3,
                        Math.sin(angle) * radius
                    );
                    window.lookAt(0, window.position.y, 0);
                    building.add(window);
                }
            }
        }

        function createSpecialArchitecture(districtType, color) {
            const group = new THREE.Group();
            
            switch(districtType) {
                case 'statistics':
                    // ä¸­å›½é¢¨ãƒ‘ã‚´ãƒ€ï¼ˆå¯æ„›ã„ãƒ”ãƒ³ã‚¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                    for (let i = 0; i < 5; i++) {
                        const level = new THREE.CylinderGeometry(6 - i, 7 - i, 3, 8);
                        const material = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(0xffb3d9).multiplyScalar(0.8 + i * 0.1),
                            roughness: 0.4,
                            metalness: 0.3,
                            transparent: true,
                            opacity: 0.85
                        });
                        const mesh = new THREE.Mesh(level, material);
                        mesh.position.y = i * 3.5;
                        mesh.castShadow = true;
                        group.add(mesh);
                    }
                    break;
                    
                case 'cognitive':
                    // æ—¥æœ¬é¢¨ã®è¤‡é›‘ãªå¡”ï¼ˆæ·¡ã„ãƒ–ãƒ«ãƒ¼ï¼‰
                    const brainGeometry = new THREE.SphereGeometry(4, 16, 16);
                    const brainMaterial = new THREE.MeshStandardMaterial({
                        color: 0xb3e0ff,
                        roughness: 0.6,
                        metalness: 0.2,
                        bumpScale: 0.1,
                        transparent: true,
                        opacity: 0.8
                    });
                    const brain = new THREE.Mesh(brainGeometry, brainMaterial);
                    brain.position.y = 8;
                    brain.castShadow = true;
                    group.add(brain);
                    
                    // ç¥çµŒãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é¢¨ã®è£…é£¾ï¼ˆå¯æ„›ã„é»„è‰²ï¼‰
                    for (let i = 0; i < 20; i++) {
                        const neuronGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                        const neuronMaterial = new THREE.MeshStandardMaterial({
                            color: 0xf9ca24,
                            emissive: 0x554422,
                            emissiveIntensity: 0.5,
                            transparent: true,
                            opacity: 0.9
                        });
                        const neuron = new THREE.Mesh(neuronGeometry, neuronMaterial);
                        neuron.position.set(
                            (Math.random() - 0.5) * 8,
                            4 + Math.random() * 8,
                            (Math.random() - 0.5) * 8
                        );
                        group.add(neuron);
                    }
                    break;
                    
                case 'development':
                    // éŸ“å›½é¢¨ã®æ®µéšå»ºç¯‰ï¼ˆãƒŸãƒ³ãƒˆã‚°ãƒªãƒ¼ãƒ³ï¼‰
                    for (let i = 0; i < 4; i++) {
                        const stageGeometry = new THREE.BoxGeometry(8 - i * 1.5, 4, 8 - i * 1.5);
                        const stageMaterial = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(0xccffcc).multiplyScalar(0.7 + i * 0.1),
                            roughness: 0.5,
                            metalness: 0.4,
                            transparent: true,
                            opacity: 0.8
                        });
                        const stage = new THREE.Mesh(stageGeometry, stageMaterial);
                        stage.position.y = i * 4 + 2;
                        stage.castShadow = true;
                        group.add(stage);
                    }
                    break;
                    
                case 'clinical':
                    // ã‚·ãƒ³ã‚¬ãƒãƒ¼ãƒ«é¢¨ã®ã‚¯ãƒªãƒ¼ãƒ³ãªåŒ»ç™‚å»ºç¯‰ï¼ˆã‚¯ãƒªãƒ¼ãƒ è‰²ï¼‰
                    const clinicalGeometry = new THREE.CylinderGeometry(5, 6, 16, 12);
                    const clinicalMaterial = new THREE.MeshStandardMaterial({
                        color: 0xfff2b3,
                        roughness: 0.2,
                        metalness: 0.8,
                        transparent: true,
                        opacity: 0.85
                    });
                    const clinical = new THREE.Mesh(clinicalGeometry, clinicalMaterial);
                    clinical.position.y = 8;
                    clinical.castShadow = true;
                    group.add(clinical);
                    
                    // åŒ»ç™‚åå­—ãƒãƒ¼ã‚¯ï¼ˆå¯æ„›ã„èµ¤ï¼‰
                    const crossMaterial = new THREE.MeshStandardMaterial({
                        color: 0xff9ff3,
                        emissive: 0x442244,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.9
                    });
                    const crossH = new THREE.BoxGeometry(4, 0.5, 0.5);
                    const crossV = new THREE.BoxGeometry(0.5, 4, 0.5);
                    const cross1 = new THREE.Mesh(crossH, crossMaterial);
                    const cross2 = new THREE.Mesh(crossV, crossMaterial);
                    cross1.position.set(0, 16, 0);
                    cross2.position.set(0, 16, 0);
                    group.add(cross1);
                    group.add(cross2);
                    break;
                    
                case 'learning':
                    // ã‚¿ã‚¤é¢¨ã®é»„é‡‘å¯ºé™¢ï¼ˆãƒ”ãƒ¼ãƒè‰²ï¼‰
                    const templeGeometry = new THREE.ConeGeometry(6, 20, 8);
                    const templeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffd9b3,
                        roughness: 0.1,
                        metalness: 0.9,
                        emissive: 0x332211,
                        emissiveIntensity: 0.2,
                        transparent: true,
                        opacity: 0.9
                    });
                    const temple = new THREE.Mesh(templeGeometry, templeMaterial);
                    temple.position.y = 10;
                    temple.castShadow = true;
                    group.add(temple);
                    
                    // é»„é‡‘ã®è£…é£¾ï¼ˆè¼ãé»„è‰²ï¼‰
                    for (let i = 0; i < 8; i++) {
                        const ornamentGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                        const ornamentMaterial = new THREE.MeshStandardMaterial({
                            color: 0xf9ca24,
                            emissive: 0x554422,
                            emissiveIntensity: 0.4,
                            transparent: true,
                            opacity: 0.9
                        });
                        const ornament = new THREE.Mesh(ornamentGeometry, ornamentMaterial);
                        const angle = (i / 8) * Math.PI * 2;
                        ornament.position.set(
                            Math.cos(angle) * 7,
                            5 + Math.sin(i) * 2,
                            Math.sin(angle) * 7
                        );
                        group.add(ornament);
                    }
                    break;
                    
                case 'social':
                    // ã‚¤ãƒ³ãƒ‰é¢¨ã®å¤šæ–‡åŒ–å»ºç¯‰ï¼ˆãƒ©ãƒ™ãƒ³ãƒ€ãƒ¼ï¼‰
                    const socialGeometry = new THREE.OctahedronGeometry(5);
                    const socialMaterial = new THREE.MeshStandardMaterial({
                        color: 0xf0b3ff,
                        roughness: 0.4,
                        metalness: 0.5,
                        transparent: true,
                        opacity: 0.85
                    });
                    const social = new THREE.Mesh(socialGeometry, socialMaterial);
                    social.position.y = 8;
                    social.castShadow = true;
                    group.add(social);
                    
                    // ã‚«ãƒ©ãƒ•ãƒ«ãªå¤šæ§˜æ€§ã®è¡¨ç¾ï¼ˆãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼ï¼‰
                    const diversityColors = [0xffb3d9, 0xb3e0ff, 0xccffcc, 0xfff2b3, 0xffd9b3, 0xf0b3ff];
                    for (let i = 0; i < 6; i++) {
                        const diversityGeometry = new THREE.BoxGeometry(1, 6, 1);
                        const diversityMaterial = new THREE.MeshStandardMaterial({
                            color: diversityColors[i],
                            emissive: diversityColors[i],
                            emissiveIntensity: 0.1,
                            transparent: true,
                            opacity: 0.8
                        });
                        const diversity = new THREE.Mesh(diversityGeometry, diversityMaterial);
                        const angle = (i / 6) * Math.PI * 2;
                        diversity.position.set(
                            Math.cos(angle) * 8,
                            3,
                            Math.sin(angle) * 8
                        );
                        group.add(diversity);
                    }
                    break;
                    
                case 'personality':
                    // é¦™æ¸¯é¢¨ã®ã‚¹ã‚¿ã‚¤ãƒªãƒƒã‚·ãƒ¥ã‚¿ãƒ¯ãƒ¼ï¼ˆã‚¢ã‚¯ã‚¢ï¼‰
                    const personalityGeometry = new THREE.CylinderGeometry(3, 4, 18, 6);
                    const personalityMaterial = new THREE.MeshStandardMaterial({
                        color: 0xb3fff0,
                        roughness: 0.2,
                        metalness: 0.8,
                        transparent: true,
                        opacity: 0.8
                    });
                    const personality = new THREE.Mesh(personalityGeometry, personalityMaterial);
                    personality.position.y = 9;
                    personality.castShadow = true;
                    group.add(personality);
                    
                    // æ€§æ ¼ç‰¹æ€§ã®5ã¤ã®æŸ±ï¼ˆãƒ‘ã‚¹ãƒ†ãƒ«ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ï¼‰
                    const traitColors = [0xffb3d9, 0xb3e0ff, 0xccffcc, 0xfff2b3, 0xffd9b3];
                    for (let i = 0; i < 5; i++) {
                        const traitGeometry = new THREE.CylinderGeometry(0.5, 0.5, 12, 8);
                        const traitMaterial = new THREE.MeshStandardMaterial({
                            color: traitColors[i],
                            emissive: traitColors[i],
                            emissiveIntensity: 0.1,
                            transparent: true,
                            opacity: 0.85
                        });
                        const trait = new THREE.Mesh(traitGeometry, traitMaterial);
                        const angle = (i / 5) * Math.PI * 2;
                        trait.position.set(
                            Math.cos(angle) * 6,
                            6,
                            Math.sin(angle) * 6
                        );
                        group.add(trait);
                    }
                    break;
                    
                case 'perception':
                    // å°æ¹¾é¢¨ã®æŠ€è¡“å»ºç¯‰ï¼ˆãƒ­ãƒ¼ã‚ºãƒ”ãƒ³ã‚¯ï¼‰
                    const perceptionGeometry = new THREE.TetrahedronGeometry(5);
                    const perceptionMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffccf2,
                        roughness: 0.3,
                        metalness: 0.7,
                        transparent: true,
                        opacity: 0.8
                    });
                    const perception = new THREE.Mesh(perceptionGeometry, perceptionMaterial);
                    perception.position.y = 8;
                    perception.castShadow = true;
                    group.add(perception);
                    
                    // çŸ¥è¦šã®éŒ¯è¦–åŠ¹æœï¼ˆç™½ã¨ãƒ”ãƒ³ã‚¯ã®äº¤äº’ï¼‰
                    for (let i = 0; i < 12; i++) {
                        const illusionGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                        const illusionMaterial = new THREE.MeshStandardMaterial({
                            color: i % 2 === 0 ? 0xffffff : 0xffccf2,
                            emissive: i % 2 === 0 ? 0x444444 : 0x442244,
                            emissiveIntensity: 0.3,
                            transparent: true,
                            opacity: 0.8
                        });
                        const illusion = new THREE.Mesh(illusionGeometry, illusionMaterial);
                        const angle = (i / 12) * Math.PI * 2;
                        illusion.position.set(
                            Math.cos(angle) * 8,
                            4 + Math.sin(i * 2) * 2,
                            Math.sin(angle) * 8
                        );
                        group.add(illusion);
                    }
                    break;
                    
                case 'neural':
                    // ãƒ™ãƒˆãƒŠãƒ é¢¨ã®ç¥çµŒç§‘å­¦ç ”ç©¶æ‰€ï¼ˆã‚·ã‚¢ãƒ³ï¼‰
                    const neuralGeometry = new THREE.SphereGeometry(4, 16, 16);
                    const neuralMaterial = new THREE.MeshStandardMaterial({
                        color: 0xccf2ff,
                        roughness: 0.5,
                        metalness: 0.3,
                        transparent: true,
                        opacity: 0.8
                    });
                    const neural = new THREE.Mesh(neuralGeometry, neuralMaterial);
                    neural.position.y = 8;
                    neural.castShadow = true;
                    group.add(neural);
                    
                    // è„³æ³¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¡¨ç¾ï¼ˆæ˜ã‚‹ã„ã‚·ã‚¢ãƒ³ï¼‰
                    for (let i = 0; i < 24; i++) {
                        const waveGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2 + Math.sin(i) * 2, 4);
                        const waveMaterial = new THREE.MeshStandardMaterial({
                            color: 0xb3fff0,
                            emissive: 0x224444,
                            emissiveIntensity: 0.5,
                            transparent: true,
                            opacity: 0.8
                        });
                        const wave = new THREE.Mesh(waveGeometry, waveMaterial);
                        const angle = (i / 24) * Math.PI * 2;
                        wave.position.set(
                            Math.cos(angle) * 6,
                            4 + Math.sin(i * 0.5) * 2,
                            Math.sin(angle) * 6
                        );
                        group.add(wave);
                    }
                    break;
                    
                default:
                    const defaultGeometry = new THREE.ConeGeometry(4, 12, 8);
                    const defaultMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffb3d9,
                        roughness: 0.3,
                        metalness: 0.5,
                        transparent: true,
                        opacity: 0.85
                    });
                    const defaultBuilding = new THREE.Mesh(defaultGeometry, defaultMaterial);
                    defaultBuilding.position.y = 6;
                    defaultBuilding.castShadow = true;
                    group.add(defaultBuilding);
            }
            
            return group;
        }

        function createEnvironmentDetails(group, color) {
            // é«˜å“è³ªãªè£…é£¾è¦ç´ 
            for (let i = 0; i < 6; i++) {
                // è¡—ç¯
                const lampGroup = new THREE.Group();
                
                const poleGeometry = new THREE.CylinderGeometry(0.2, 0.3, 8);
                const poleMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffeaa7, // å„ªã—ã„ã‚´ãƒ¼ãƒ«ãƒ‰
                    roughness: 0.8,
                    metalness: 0.9,
                    transparent: true,
                    opacity: 0.9
                });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.y = 4;
                pole.castShadow = true;
                lampGroup.add(pole);
                
                const lightGeometry = new THREE.SphereGeometry(1, 12, 12);
                const lightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xfffbf0, // æ¸©ã‹ã„ç™½
                    emissive: 0xfff8aa,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffff88,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.y = 8.5;
                lampGroup.add(light);
                
                const angle = (i / 6) * Math.PI * 2;
                const radius = 20 + Math.random() * 10;
                lampGroup.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                
                group.add(lampGroup);
            }
            
            // æ¤ç‰©ã‚„è£…é£¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            for (let i = 0; i < 12; i++) {
                const decorGeometry = new THREE.ConeGeometry(0.5, 4, 6);
                const decorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xc8e6c9, // å„ªã—ã„ãƒŸãƒ³ãƒˆã‚°ãƒªãƒ¼ãƒ³
                    roughness: 0.9,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.85
                });
                const decoration = new THREE.Mesh(decorGeometry, decorMaterial);
                decoration.position.set(
                    (Math.random() - 0.5) * 40,
                    2,
                    (Math.random() - 0.5) * 40
                );
                decoration.castShadow = true;
                group.add(decoration);
            }
        }

        function createRoads() {
            // ç¾ã—ã„é“è·¯ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼ï¼‰
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0xdda0dd, // å¯æ„›ã„ãƒ—ãƒ©ãƒ ã‚«ãƒ©ãƒ¼
                roughness: 0.8,
                metalness: 0.2,
                transparent: true,
                opacity: 0.8
            });

            // ãƒ¡ã‚¤ãƒ³ç’°çŠ¶é“è·¯
            const ringGeometry = new THREE.RingGeometry(60, 64, 64);
            const ring = new THREE.Mesh(ringGeometry, roadMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            ring.receiveShadow = true;
            scene.add(ring);

            // æ”¾å°„çŠ¶ã®é“è·¯ï¼ˆå„åŒºåŸŸã‚’ç¹‹ãã€å¯æ„›ã„ãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼ï¼‰
            const roadColors = [0xffb3d9, 0xb3e0ff, 0xccffcc, 0xfff2b3, 0xffd9b3, 0xf0b3ff, 0xb3fff0, 0xffccf2, 0xccf2ff];
            Object.keys(districtData).forEach((key, index) => {
                const district = districtData[key];
                const roadGeometry = new THREE.PlaneGeometry(4, 80);
                const coloredRoadMaterial = new THREE.MeshStandardMaterial({
                    color: roadColors[index] || 0xf8d7da,
                    roughness: 0.6,
                    metalness: 0.3,
                    transparent: true,
                    opacity: 0.7
                });
                const road = new THREE.Mesh(roadGeometry, coloredRoadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.position.set(district.position[0] / 2, 0.2, district.position[2] / 2);
                road.lookAt(0, 0.2, 0);
                road.receiveShadow = true;
                scene.add(road);
            });

            // äº¤å·®ç‚¹ï¼ˆè™¹è‰²ï¼‰
            const intersectionGeometry = new THREE.CylinderGeometry(8, 8, 0.5, 16);
            const intersectionMaterial = new THREE.MeshStandardMaterial({
                color: 0xffeaa7, // å„ªã—ã„ã‚¯ãƒªãƒ¼ãƒ è‰²
                roughness: 0.7,
                metalness: 0.4,
                transparent: true,
                opacity: 0.8
            });
            const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
            intersection.position.y = 0.25;
            intersection.receiveShadow = true;
            scene.add(intersection);
        }

        function createLabel(text, x, y, z) {
            // åŒºåŸŸãƒãƒ¼ã‚«ãƒ¼ï¼ˆã‚­ãƒ©ã‚­ãƒ©æ˜Ÿå‹ï¼‰
            const markerGeometry = new THREE.ConeGeometry(1.5, 3, 8);
            const markerMaterial = new THREE.MeshStandardMaterial({
                color: 0xf9ca24, // è¼ãã‚´ãƒ¼ãƒ«ãƒ‰
                emissive: 0x554422,
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.9
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, y, z);
            marker.castShadow = true;
            scene.add(marker);

            // ãƒ‘ãƒ«ã‚¹åŠ¹æœã®ãŸã‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒãƒ¼ã‚«ãƒ¼ä¿å­˜
            marker.userData = { originalScale: marker.scale.clone(), pulseTime: Math.random() * Math.PI * 2 };
            if (!scene.userData.markers) scene.userData.markers = [];
            scene.userData.markers.push(marker);
        }

        function addAdvancedMouseControls() {
            let mouseDown = false;
            let mouseButton = 0;
            let mouseX = 0;
            let mouseY = 0;
            let mouseSensitivity = 0.002;

            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseButton = event.button;
                mouseX = event.clientX;
                mouseY = event.clientY;
                event.preventDefault();
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                if (viewMode === 'orbit') {
                    // è»Œé“ã‚«ãƒ¡ãƒ©ï¼ˆå¾“æ¥ã®å‹•ä½œï¼‰
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaX * mouseSensitivity;
                    spherical.phi += deltaY * mouseSensitivity;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                } else if (viewMode === 'fly' || viewMode === 'fps') {
                    // ãƒ•ãƒ©ã‚¤/FPSã‚«ãƒ¡ãƒ©
                    camera.rotation.y -= deltaX * mouseSensitivity;
                    camera.rotation.x -= deltaY * mouseSensitivity;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                }

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                if (viewMode === 'orbit') {
                    const distance = camera.position.length();
                    const newDistance = distance + event.deltaY * 0.01;
                    const clampedDistance = Math.max(10, Math.min(200, newDistance));
                    
                    camera.position.normalize().multiplyScalar(clampedDistance);
                    camera.lookAt(0, 0, 0);
                } else {
                    // ãƒ•ãƒ©ã‚¤/FPSãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚ºãƒ¼ãƒ ã§ã‚¹ãƒ”ãƒ¼ãƒ‰èª¿æ•´
                    flySpeed = Math.max(0.1, Math.min(5.0, flySpeed + event.deltaY * 0.001));
                }
                event.preventDefault();
            });

            // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯ï¼ˆFPSãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
            renderer.domElement.addEventListener('click', () => {
                if (viewMode === 'fps') {
                    renderer.domElement.requestPointerLock();
                }
            });
        }

        function addKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                
                // ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚­ãƒ¼
                switch(event.code) {
                    case 'Digit1': setViewMode('orbit'); break;
                    case 'Digit2': setViewMode('fly'); break;
                    case 'Digit3': setViewMode('fps'); break;
                    case 'KeyR': resetCamera(); break;
                    case 'KeyW': toggleWireframe(); break;
                    case 'KeyF': toggleFullscreen(); break;
                    case 'Escape': exitPointerLock(); break;
                }
            });

            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });
        }

        function updateCameraMovement() {
            if (viewMode === 'fly' || viewMode === 'fps') {
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                const up = new THREE.Vector3(0, 1, 0);
                
                forward.applyQuaternion(camera.quaternion);
                right.applyQuaternion(camera.quaternion);
                
                velocity.set(0, 0, 0);
                
                if (keys['KeyW']) velocity.add(forward.multiplyScalar(flySpeed));
                if (keys['KeyS']) velocity.add(forward.multiplyScalar(-flySpeed));
                if (keys['KeyA']) velocity.add(right.multiplyScalar(-flySpeed));
                if (keys['KeyD']) velocity.add(right.multiplyScalar(flySpeed));
                if (keys['Space']) velocity.add(up.multiplyScalar(flySpeed));
                if (keys['ShiftLeft']) velocity.add(up.multiplyScalar(-flySpeed));
                
                camera.position.add(velocity);
                
                // å¢ƒç•Œåˆ¶é™
                camera.position.x = Math.max(-150, Math.min(150, camera.position.x));
                camera.position.z = Math.max(-150, Math.min(150, camera.position.z));
                camera.position.y = Math.max(1, Math.min(150, camera.position.y));
            }
        }

        function setViewMode(mode) {
            viewMode = mode;
            updateInfo(`ğŸ¥ ${mode.toUpperCase()}ãƒ¢ãƒ¼ãƒ‰`, `ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ãŒ${mode}ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚`);
            
            if (mode === 'fps') {
                updateInfo(`ğŸ‘¤ FPSãƒ¢ãƒ¼ãƒ‰`, `WASD:ç§»å‹• ã‚¹ãƒšãƒ¼ã‚¹:ä¸Šæ˜‡ Shift:ä¸‹é™ ãƒã‚¦ã‚¹:è¦–ç‚¹å¤‰æ›´ ã‚¯ãƒªãƒƒã‚¯ã§ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯`);
            } else if (mode === 'fly') {
                updateInfo(`ğŸš ãƒ•ãƒ©ã‚¤ãƒ¢ãƒ¼ãƒ‰`, `WASD:ç§»å‹• ã‚¹ãƒšãƒ¼ã‚¹:ä¸Šæ˜‡ Shift:ä¸‹é™ ãƒã‚¦ã‚¹:è¦–ç‚¹å¤‰æ›´ ãƒ›ã‚¤ãƒ¼ãƒ«:ã‚¹ãƒ”ãƒ¼ãƒ‰èª¿æ•´`);
            } else {
                updateInfo(`ğŸŒ è»Œé“ãƒ¢ãƒ¼ãƒ‰`, `ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°:å›è»¢ ãƒ›ã‚¤ãƒ¼ãƒ«:ã‚ºãƒ¼ãƒ  è‡ªå‹•ã§ä¸­å¿ƒã‚’æ³¨è¦–`);
            }
        }

        function resetCamera() {
            camera.position.set(0, 50, 100); // ã‚ˆã‚Šè¿‘ã„ä½ç½®
            camera.rotation.set(0, 0, 0);
            camera.lookAt(0, 0, 0);
            viewMode = 'orbit';
            updateInfo("ğŸ¯ ã‚«ãƒ¡ãƒ©ãƒªã‚»ãƒƒãƒˆ", "ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’åˆæœŸçŠ¶æ…‹ã«æˆ»ã—ã¾ã—ãŸã€‚å»ºç‰©ãŒè¦‹ãˆã‚‹ã¯ãšã§ã™ï¼");
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            
            scene.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.wireframe = wireframeMode);
                    } else {
                        child.material.wireframe = wireframeMode;
                    }
                }
            });
            
            updateInfo("ğŸ“ ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ", `ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤º: ${wireframeMode ? 'ON' : 'OFF'}`);
        }

        function toggleFullscreen() {
            if (!isFullscreen) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
                isFullscreen = true;
                updateInfo("ğŸ–¥ï¸ å…¨ç”»é¢ãƒ¢ãƒ¼ãƒ‰", "å…¨ç”»é¢è¡¨ç¤ºã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚ESCã‚­ãƒ¼ã§çµ‚äº†ã§ãã¾ã™ã€‚");
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                isFullscreen = false;
                updateInfo("ğŸªŸ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ¢ãƒ¼ãƒ‰", "ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¡¨ç¤ºã«æˆ»ã‚Šã¾ã—ãŸã€‚");
            }
        }

        function exitPointerLock() {
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }

        function focusDistrict(districtKey) {
            if (districtKey === 'overview') {
                camera.position.set(0, 60, 80); // ã‚ˆã‚Šè¿‘ã„å…¨ä½“è¡¨ç¤º
                camera.lookAt(0, 0, 0);
                updateInfo("ğŸŒ† å…¨ä½“è¡¨ç¤º", "å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£å…¨ä½“ã‚’ä¿¯ç°è¡¨ç¤ºã€‚å„åŒºåŸŸãŒæœ‰æ©Ÿçš„ã«é€£æºã—ã¦ã„ã‚‹æ§˜å­ã‚’ç¢ºèªã§ãã¾ã™ã€‚9ã¤ã®å¿ƒç†å­¦åˆ†é‡ãŒç¾ã—ãé…ç½®ã•ã‚Œã¦ã„ã¾ã™ã€‚");
                return;
            }

            const district = districtData[districtKey];
            if (district) {
                camera.position.set(
                    district.position[0] + 25, // ã‚ˆã‚Šè¿‘ã¥ã
                    30,
                    district.position[2] + 25
                );
                camera.lookAt(district.position[0], 0, district.position[2]);
                updateInfo(district.name, district.description);
            }
        }

        function updateInfo(title, description) {
            const infoDiv = document.getElementById('district-info');
            infoDiv.innerHTML = `<strong>${title}</strong><br>${description}<br><em>ãƒã‚¦ã‚¹ã§å›è»¢ã€ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ </em>`;
        }

        function animate() {
            requestAnimationFrame(animate);

            // ã‚«ãƒ¡ãƒ©ç§»å‹•ã®æ›´æ–°
            updateCameraMovement();

            // æ™‚é–“ãƒ™ãƒ¼ã‚¹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            const time = Date.now() * 0.001;

            // å»ºç‰©ã®è»½ã„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå‘¼å¸ã™ã‚‹ã‚ˆã†ãªå‹•ãï¼‰
            Object.keys(districts).forEach((key, index) => {
                const district = districts[key];
                if (district) {
                    district.children.forEach((building, buildingIndex) => {
                        if (buildingIndex > 0) { // ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ«ãƒ‡ã‚£ãƒ³ã‚°ä»¥å¤–
                            const originalY = building.userData.originalY || building.position.y;
                            building.userData.originalY = originalY;
                            building.position.y = originalY + Math.sin(time * 2 + index + buildingIndex) * 0.3;
                        }
                        
                        // å»ºç‰©ã®å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç‰¹æ®Šå»ºç¯‰ç‰©ï¼‰
                        if (buildingIndex === 0 && building.children.length > 0) {
                            building.rotation.y += 0.005;
                        }
                    });
                }
            });

            // ãƒãƒ¼ã‚«ãƒ¼ã®ãƒ‘ãƒ«ã‚¹åŠ¹æœ
            if (scene.userData.markers) {
                scene.userData.markers.forEach((marker, index) => {
                    const pulseTime = marker.userData.pulseTime + time;
                    const scale = 1 + Math.sin(pulseTime * 3) * 0.2;
                    marker.scale.setScalar(scale);
                    marker.rotation.y += 0.02;
                });
            }

            // é›²ã®ç§»å‹•
            scene.traverse((child) => {
                if (child.isMesh && child.position.y > 50 && child.material.opacity < 1) {
                    child.position.x += Math.sin(time * 0.1 + child.position.z * 0.01) * 0.1;
                    child.position.z += Math.cos(time * 0.1 + child.position.x * 0.01) * 0.1;
                    child.rotation.y += 0.001;
                }
            });

            // æ°´é¢ã®æ³¢ç´‹åŠ¹æœ
            scene.traverse((child) => {
                if (child.isMesh && child.position.y < 0 && child.material.opacity < 1) {
                    const vertices = child.geometry.attributes.position.array;
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i];
                        const z = vertices[i + 2];
                        vertices[i + 1] = Math.sin(time * 2 + x * 0.1) * Math.cos(time * 2 + z * 0.1) * 0.5;
                    }
                    child.geometry.attributes.position.needsUpdate = true;
                }
            });

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœï¼ˆå…‰ã®ç²’å­ï¼‰
            createParticleEffects(time);

            renderer.render(scene, camera);
        }

        function createParticleEffects(time) {
            // æ—¢å­˜ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
            if (scene.userData.particles) {
                scene.userData.particles.forEach(particle => {
                    scene.remove(particle);
                });
                scene.userData.particles = [];
            } else {
                scene.userData.particles = [];
            }

            // æ–°ã—ã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œæˆï¼ˆè™¹è‰²ï¼‰
            for (let i = 0; i < 50; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const hue = (i / 50) * 360; // è™¹è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue / 360, 0.7, 0.8),
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.set(
                    (Math.random() - 0.5) * 200,
                    Math.random() * 100 + 20,
                    (Math.random() - 0.5) * 200
                );
                
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.2
                );
                
                scene.add(particle);
                scene.userData.particles.push(particle);
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç§»å‹•
            scene.userData.particles.forEach((particle, index) => {
                particle.position.add(particle.userData.velocity);
                particle.rotation.x += 0.01;
                particle.rotation.y += 0.01;
                
                // å¢ƒç•Œã‚’è¶…ãˆãŸã‚‰å†é…ç½®
                if (particle.position.length() > 150) {
                    particle.position.set(
                        (Math.random() - 0.5) * 50,
                        Math.random() * 50 + 20,
                        (Math.random() - 0.5) * 50
                    );
                }
            });
        }

        function downloadHTML() {
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html; charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£3D.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            updateInfo("ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†", "å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£3Dã®HTMLãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸï¼");
        }

        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³å¤‰æ›´ã®æ¤œå‡º
        document.addEventListener('fullscreenchange', () => {
            isFullscreen = !!document.fullscreenElement;
        });

        // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯å¤‰æ›´ã®æ¤œå‡º
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === renderer.domElement) {
                updateInfo("ğŸ”’ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯", "FPSãƒ¢ãƒ¼ãƒ‰ã§ãƒã‚¦ã‚¹ãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸã€‚ESCã§è§£é™¤ã§ãã¾ã™ã€‚");
            } else {
                updateInfo("ğŸ”“ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯è§£é™¤", "ãƒã‚¦ã‚¹ãƒ­ãƒƒã‚¯ãŒè§£é™¤ã•ã‚Œã¾ã—ãŸã€‚");
            }
        });

        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();

        // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        setTimeout(() => {
            updateInfo("ğŸŒŸ å¿ƒç†å­¦ãƒ¡ã‚¬ã‚·ãƒ†ã‚£ã¸ã‚ˆã†ã“ãï¼", "9ã¤ã®å¿ƒç†å­¦åˆ†é‡ãŒç¾ã—ã„3Déƒ½å¸‚ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚å„åŒºåŸŸã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ¢ç´¢ã—ã¾ã—ã‚‡ã†ï¼");
        }, 1000);
    </script>
</body>
</html>